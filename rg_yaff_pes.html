
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>2. yaff.pes – Force-field potential energy surfaces (PESs) &mdash; Yaff 1.0 documentation</title>
    
    <link rel="stylesheet" href="_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="Yaff 1.0 documentation" href="index.html" />
    <link rel="next" title="3. yaff.sampling – Phase-space sampling" href="rg_yaff_sampling.html" />
    <link rel="prev" title="1. yaff – YAFF - Yet another force field" href="rg_yaff.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="rg_yaff_sampling.html" title="3. yaff.sampling – Phase-space sampling"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="rg_yaff.html" title="1. yaff – YAFF - Yet another force field"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Yaff 1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="yaff-pes-force-field-potential-energy-surfaces-pess">
<h1>2. <tt class="docutils literal"><span class="pre">yaff.pes</span></tt> &#8211; Force-field potential energy surfaces (PESs)<a class="headerlink" href="#yaff-pes-force-field-potential-energy-surfaces-pess" title="Permalink to this headline">¶</a></h1>
<div class="section" id="module-yaff.pes.dlist">
<span id="yaff-pes-dlist-short-range-neighbor-lists-for-covalent-energy-terms"></span><h2>2.1. <tt class="docutils literal"><span class="pre">yaff.pes.dlist</span></tt> &#8211; Short-range neighbor lists for covalent energy terms<a class="headerlink" href="#module-yaff.pes.dlist" title="Permalink to this headline">¶</a></h2>
<p>Short-range neighbor lists for covalent energy terms</p>
<p>The short-range neighbor lits are called Delta lists. They are used for the
covalent energy terms that do not allow for bond breaking.</p>
<p>The delta list contains all relative vectors that are needed to evaluate
the covalent energy terms. The minimum image convention (MIC) is used to make
sure that periodic boundary conditions are taken into account. The current
implementation of the MIC in Yaff works in principle only for orthorhombic
cells. In the general case of a triclinic cell, the Yaff implementation is
known to fail in some corner cases, e.g. in small and very skewed unit cells.
The derivative of the energy towards the components of the relative vectors
is computed if the ForceField.compute routine requires energy derivatives.</p>
<p>The class <a class="reference internal" href="#yaff.pes.dlist.DeltaList" title="yaff.pes.dlist.DeltaList"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.dlist.DeltaList</span></tt></a> is intimately related
to classes <a class="reference internal" href="#yaff.pes.iclist.InternalCoordinateList" title="yaff.pes.iclist.InternalCoordinateList"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.iclist.InternalCoordinateList</span></tt></a> and
<a class="reference internal" href="#yaff.pes.vlist.ValenceList" title="yaff.pes.vlist.ValenceList"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.vlist.ValenceList</span></tt></a>. They work together, just like layers in
a neural network, and they use the back-propagation algorithm to compute
partial derivatives. The order of the layers is as follows:</p>
<div class="highlight-python"><pre>DeltaList &lt;--&gt; InternalCoordinateList &lt;--&gt; ValenceList</pre>
</div>
<p>The class <a class="reference internal" href="#yaff.pes.ff.ForcePartValence" title="yaff.pes.ff.ForcePartValence"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.ff.ForcePartValence</span></tt></a> ties these three lists
together. The basic idea of the back-propagation algorithm is explained in
the section <a class="reference internal" href="dg_backprop.html#dg-sec-backprop"><em>The back-propagation algorithm for the computation of energy derivatives</em></a>.</p>
<dl class="class">
<dt id="yaff.pes.dlist.DeltaList">
<em class="property">class </em><tt class="descclassname">yaff.pes.dlist.</tt><tt class="descname">DeltaList</tt><big>(</big><em>system</em><big>)</big><a class="headerlink" href="#yaff.pes.dlist.DeltaList" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Class to store, manage and evaluate the delta list.</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>system</dt>
<dd>A <tt class="docutils literal"><span class="pre">System</span></tt> instance.</dd>
</dl>
<dl class="method">
<dt id="yaff.pes.dlist.DeltaList.add_delta">
<tt class="descname">add_delta</tt><big>(</big><em>i</em>, <em>j</em><big>)</big><a class="headerlink" href="#yaff.pes.dlist.DeltaList.add_delta" title="Permalink to this definition">¶</a></dt>
<dd><p>Register a new relative vector in the delta list</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>i, j</dt>
<dd>Indexes of the first and second atom. The vector points from
i to j.</dd>
</dl>
<p><strong>Returns:</strong></p>
<dl class="docutils">
<dt>row</dt>
<dd>The row index of the newly registered relative vector, for later
reference.</dd>
<dt>sign</dt>
<dd>Is -1 when i and j were swapped during the registration. Is +1
otherwise.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="yaff.pes.dlist.DeltaList.forward">
<tt class="descname">forward</tt><big>(</big><big>)</big><a class="headerlink" href="#yaff.pes.dlist.DeltaList.forward" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the relative vectors for <tt class="docutils literal"><span class="pre">self.system.pos</span></tt></p>
<p>The actual computation is carried out by a low-level C routine.</p>
</dd></dl>

<dl class="method">
<dt id="yaff.pes.dlist.DeltaList.back">
<tt class="descname">back</tt><big>(</big><em>gpos</em>, <em>vtens</em><big>)</big><a class="headerlink" href="#yaff.pes.dlist.DeltaList.back" title="Permalink to this definition">¶</a></dt>
<dd><p>Derive gpos and virial from the derivatives towards the relative vectors</p>
<p>The actual computation is carried out by a low-level C routine.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-yaff.pes.ext">
<span id="yaff-pes-ext-low-level-c-routines"></span><h2>2.2. <tt class="docutils literal"><span class="pre">yaff.pes.ext</span></tt> &#8211; Low-level C routines<a class="headerlink" href="#module-yaff.pes.ext" title="Permalink to this headline">¶</a></h2>
<p>Low-level C routines</p>
<p>This extension module is used by various modules of the <tt class="docutils literal"><span class="pre">yaff.pes</span></tt>
package.</p>
<dl class="class">
<dt id="yaff.pes.ext.Cell">
<em class="property">class </em><tt class="descclassname">yaff.pes.ext.</tt><tt class="descname">Cell</tt><a class="headerlink" href="#yaff.pes.ext.Cell" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Cell(ndarray rvecs)
Representation of periodic boundary conditions.</p>
<blockquote>
<div>0, 1, 2 and 3 dimensional systems are supported. The cell vectors need
not to be orthogonal.</div></blockquote>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>rvecs</dt>
<dd>A numpy array with at most three cell vectors, layed out as
rows in a rank-2 matrix. For non-periodic systems, this array
must have shape (0,3).</dd>
</dl>
<dl class="method">
<dt id="yaff.pes.ext.Cell.add_vec">
<tt class="descname">add_vec</tt><big>(</big><em>self</em>, <em>ndarray delta</em>, <em>ndarray r</em><big>)</big><a class="headerlink" href="#yaff.pes.ext.Cell.add_vec" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a linear combination of cell vectors, <tt class="docutils literal"><span class="pre">r</span></tt>, to <tt class="docutils literal"><span class="pre">delta</span></tt> in-place</p>
</dd></dl>

<dl class="method">
<dt id="yaff.pes.ext.Cell.compute_distances">
<tt class="descname">compute_distances</tt><big>(</big><em>self</em>, <em>ndarray output</em>, <em>ndarray pos0</em>, <em>ndarray pos1=None</em>, <em>ndarray pairs=None</em>, <em>bool do_include=False</em>, <em>long nimage=0</em><big>)</big><a class="headerlink" href="#yaff.pes.ext.Cell.compute_distances" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes all distances between the given coordinates</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>output</dt>
<dd>An numpy vector of the proper length that will be used to store
all the distances.</dd>
<dt>pos0</dt>
<dd>An array with Cartesian coordinates</dd>
</dl>
<p><strong>Optional arguments:</strong></p>
<dl class="docutils">
<dt>pos1</dt>
<dd>A second array with Cartesian coordinates</dd>
<dt>pairs</dt>
<dd><p class="first">A sorted array of atom pairs. When do_include==False, this list
will be excluded from the computation. When do_include==True,
only these pairs are considered when computing distances.</p>
<p class="last">The indexes in this array refer to rows of pos0 or pos1. If pos1
is not given, both columns refer to rows of pos0. If pos1 is
given, the first column refers to rows of pos0 and the second
column refers to rows of pos1. The rows in the pairst array
should be sorted lexicographically, first along the first
column, then along the second column.</p>
</dd>
<dt>do_include</dt>
<dd>True or False, controls how the pairs list is interpreted. When
set to True, nimage must be zero and the pairs attribute must be
a non-empty array.</dd>
<dt>nimage</dt>
<dd>The number of cell images to consider in the computation of the
pair distances. By default, this is zero, meaning that only the
minimum image convention is used.</dd>
</dl>
<p>This routine can operate in two different ways, depending on the
presence/absence of the argument <tt class="docutils literal"><span class="pre">pos1</span></tt>. If not given, all
distances between points in <tt class="docutils literal"><span class="pre">pos0</span></tt> are computed and the length of
the output array is <tt class="docutils literal"><span class="pre">len(pos0)*(len(pos0)-1)/2</span></tt>. If <tt class="docutils literal"><span class="pre">pos1</span></tt> is
given, all distances are computed between a point in <tt class="docutils literal"><span class="pre">pos0</span></tt> and a
point in <tt class="docutils literal"><span class="pre">pos1</span></tt> and the length of the output array is
<tt class="docutils literal"><span class="pre">len(pos0)*len(pos1)</span></tt>.</p>
<p>In both cases, some pairs of atoms may be
excluded from the output with the <tt class="docutils literal"><span class="pre">exclude</span></tt> argument. In typical
cases, this list of excluded pairs is relatively short. In case,
the exclude argument is present the number of computed distances
is less than explained above, but it is recommended to still use
those sizes in case some pairs in the excluded list are not
applicable.</p>
</dd></dl>

<dl class="attribute">
<dt id="yaff.pes.ext.Cell.gspacings">
<tt class="descname">gspacings</tt><a class="headerlink" href="#yaff.pes.ext.Cell.gspacings" title="Permalink to this definition">¶</a></dt>
<dd><p>Cell._get_gspacings(self, full=False)
The (orthogonal) spacing between opposite sides of the reciprocal-space unit cell.</p>
</dd></dl>

<dl class="attribute">
<dt id="yaff.pes.ext.Cell.gvecs">
<tt class="descname">gvecs</tt><a class="headerlink" href="#yaff.pes.ext.Cell.gvecs" title="Permalink to this definition">¶</a></dt>
<dd><p>Cell._get_gvecs(self, full=False)
The reciporcal-space cell vectors, layed out as rows.</p>
</dd></dl>

<dl class="method">
<dt id="yaff.pes.ext.Cell.mic">
<tt class="descname">mic</tt><big>(</big><em>self</em>, <em>ndarray delta</em><big>)</big><a class="headerlink" href="#yaff.pes.ext.Cell.mic" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the minimum image convention to delta in-place</p>
</dd></dl>

<dl class="attribute">
<dt id="yaff.pes.ext.Cell.nvec">
<tt class="descname">nvec</tt><a class="headerlink" href="#yaff.pes.ext.Cell.nvec" title="Permalink to this definition">¶</a></dt>
<dd><p>Cell._get_nvec(self)
The number of cell vectors</p>
</dd></dl>

<dl class="attribute">
<dt id="yaff.pes.ext.Cell.parameters">
<tt class="descname">parameters</tt><a class="headerlink" href="#yaff.pes.ext.Cell.parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Cell._get_parameters(self)
The cell parameters (lengths and angles)</p>
</dd></dl>

<dl class="attribute">
<dt id="yaff.pes.ext.Cell.rspacings">
<tt class="descname">rspacings</tt><a class="headerlink" href="#yaff.pes.ext.Cell.rspacings" title="Permalink to this definition">¶</a></dt>
<dd><p>Cell._get_rspacings(self, full=False)
The (orthogonal) spacing between opposite sides of the real-space unit cell.</p>
</dd></dl>

<dl class="attribute">
<dt id="yaff.pes.ext.Cell.rvecs">
<tt class="descname">rvecs</tt><a class="headerlink" href="#yaff.pes.ext.Cell.rvecs" title="Permalink to this definition">¶</a></dt>
<dd><p>Cell._get_rvecs(self, full=False)
The real-space cell vectors, layed out as rows.</p>
</dd></dl>

<dl class="method">
<dt id="yaff.pes.ext.Cell.to_center">
<tt class="descname">to_center</tt><big>(</big><em>self</em>, <em>ndarray pos</em><big>)</big><a class="headerlink" href="#yaff.pes.ext.Cell.to_center" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the corresponding position in the central cell</p>
</dd></dl>

<dl class="method">
<dt id="yaff.pes.ext.Cell.update_rvecs">
<tt class="descname">update_rvecs</tt><big>(</big><em>self</em>, <em>ndarray rvecs</em><big>)</big><a class="headerlink" href="#yaff.pes.ext.Cell.update_rvecs" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the cell vectors and recompute the reciprocal cell vectors.</p>
<dl class="docutils">
<dt>rvecs</dt>
<dd>A numpy array with at most three cell vectors, layed out as
rows in a rank-2 matrix. For non-periodic systems, this array
must have shape (0,3).</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="yaff.pes.ext.Cell.volume">
<tt class="descname">volume</tt><a class="headerlink" href="#yaff.pes.ext.Cell.volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Cell._get_volume(self)
The generalize volume of the unit cell (length, area or volume)</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="yaff.pes.ext.nlist_status_init">
<tt class="descclassname">yaff.pes.ext.</tt><tt class="descname">nlist_status_init</tt><big>(</big><em>rmax</em><big>)</big><a class="headerlink" href="#yaff.pes.ext.nlist_status_init" title="Permalink to this definition">¶</a></dt>
<dd><p>nlist_status_init(rmax)</p>
<p>Creates a new <tt class="docutils literal"><span class="pre">nlists_status</span></tt> array</p>
<p>The array consists of seven integer elements with the following meaning:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">r0</span></tt>: relative image index along a direction</li>
<li><tt class="docutils literal"><span class="pre">r1</span></tt>: relative image index along b direction</li>
<li><tt class="docutils literal"><span class="pre">r2</span></tt>: relative image index along c direction</li>
<li><tt class="docutils literal"><span class="pre">a</span></tt>: atom index of first atom in pair</li>
<li><tt class="docutils literal"><span class="pre">b</span></tt>: atom index of second atom in pair</li>
<li><tt class="docutils literal"><span class="pre">sign</span></tt>: +1 or -1, to swap the relative vector such that a &gt; b</li>
<li><tt class="docutils literal"><span class="pre">nrow</span></tt>: number of rows consumed</li>
</ul>
</dd></dl>

<dl class="function">
<dt id="yaff.pes.ext.nlist_build">
<tt class="descclassname">yaff.pes.ext.</tt><tt class="descname">nlist_build</tt><big>(</big><em>ndarray pos</em>, <em>double rcut</em>, <em>ndarray rmax</em>, <em>Cell unitcell</em>, <em>ndarray status</em>, <em>ndarray neighs</em><big>)</big><a class="headerlink" href="#yaff.pes.ext.nlist_build" title="Permalink to this definition">¶</a></dt>
<dd><p>Scan the system for all pairs that have a distance smaller than rcut until the neighs array is filled or all pairs are considered</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>pos</dt>
<dd>The numpy array with the atomic positions, shape (natom, 3)</dd>
<dt>rcut</dt>
<dd>The cutoff radius</dd>
<dt>rmax</dt>
<dd>The number of periodic images to visit along each cell vector, shape
(nrvec,)</dd>
<dt>unitcell</dt>
<dd>An instance of the UnitCell class, describing the periodic boundary
conditions.</dd>
<dt>status</dt>
<dd>The status array, either obtained from <tt class="docutils literal"><span class="pre">nlist_status_init</span></tt>, or
as it was modified by the last call to this function</dd>
<dt>neighs</dt>
<dd>The neighbor list array. One element is of the datatype
nlist.neigh_row_type.</dd>
</dl>
<p><strong>Returns:</strong></p>
<p><tt class="docutils literal"><span class="pre">True</span></tt> if the neighbor list is complete. <tt class="docutils literal"><span class="pre">False</span></tt> otherwise</p>
</dd></dl>

<dl class="function">
<dt id="yaff.pes.ext.nlist_status_finish">
<tt class="descclassname">yaff.pes.ext.</tt><tt class="descname">nlist_status_finish</tt><big>(</big><em>status</em><big>)</big><a class="headerlink" href="#yaff.pes.ext.nlist_status_finish" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>status</dt>
<dd>The status array, either obtained from <tt class="docutils literal"><span class="pre">nlist_status_init</span></tt>, or
as it was modified by the last call to this function</dd>
</dl>
<p>Returns the number of rows generated by the neighbor list algorithm</p>
</dd></dl>

<dl class="function">
<dt id="yaff.pes.ext.nlist_recompute">
<tt class="descclassname">yaff.pes.ext.</tt><tt class="descname">nlist_recompute</tt><big>(</big><em>ndarray pos</em>, <em>ndarray pos_old</em>, <em>Cell unitcell</em>, <em>ndarray neighs</em><big>)</big><a class="headerlink" href="#yaff.pes.ext.nlist_recompute" title="Permalink to this definition">¶</a></dt>
<dd><p>Recompute all relative vectors and distances in the neighbor list.</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>pos</dt>
<dd>The numpy array with the atomic positions, shape (natom, 3)</dd>
<dt>pos_old</dt>
<dd>The positions used during the last neighbor list rebuild. These
are used to make sure that there are no sudden jumps in the
relative vectors due to the minimum image convention.</dd>
<dt>unitcell</dt>
<dd>An instance of the UnitCell class, describing the periodic boundary
conditions.</dd>
<dt>neighs</dt>
<dd>The neighbor list array. One element is of the datatype
nlist.neigh_row_type.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yaff.pes.ext.nlist_inc_r">
<tt class="descclassname">yaff.pes.ext.</tt><tt class="descname">nlist_inc_r</tt><big>(</big><em>Cell unitcell</em>, <em>ndarray r</em>, <em>ndarray rmax</em><big>)</big><a class="headerlink" href="#yaff.pes.ext.nlist_inc_r" title="Permalink to this definition">¶</a></dt>
<dd><p>Increment the vector <tt class="docutils literal"><span class="pre">r</span></tt> to the location of the <cite>next</cite> periodic image.</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>unitcell</dt>
<dd>An instance of the UnitCell class, describing the periodic boundary
conditions.</dd>
<dt>r</dt>
<dd>An array of integers describing the current image. This will be
incremented in place.</dd>
<dt>rmax</dt>
<dd>An array of integers specifying the range of periodic images that
must be visited along each cell vector.</dd>
</dl>
<p><strong>Returns:</strong></p>
<p>True if the counter <tt class="docutils literal"><span class="pre">r</span></tt> was at the last image and is therefore reset
to the first image. False in all other cases.</p>
<p><strong>Description:</strong></p>
<p>This Python wrapper is only present for debugging purposes. Note that
this routine visits only half of the periodic images because the other
half contains exactly the same relative vectors.</p>
</dd></dl>

<dl class="class">
<dt id="yaff.pes.ext.Hammer">
<em class="property">class </em><tt class="descclassname">yaff.pes.ext.</tt><tt class="descname">Hammer</tt><a class="headerlink" href="#yaff.pes.ext.Hammer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.ext.Truncation</span></tt></p>
<p>An old-fashioned and poor truncation scheme.</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>tau</dt>
<dd>The tau parameter in the mathematical expression below.</dd>
</dl>
<p>Don&#8217;t use this truncation scheme. Only present for historical reasons.
The mathematical form is as follows:</p>
<div class="math">
<p><img src="_images/math/ace601a9659f99a49d6207b722de7687ad8e289f.png" alt="t_\text{hammer}(d) = \left\lbrace \begin{array}{ll}
    \exp\left(\frac{\tau}{d-r_\text{rcut}}\right) &amp; \text{if } d &lt; r_\text{cut} \\
    0 &amp; \text{if } d &gt;= r_\text{cut}
\end{array} \right."/></p>
</div><dl class="method">
<dt id="yaff.pes.ext.Hammer.get_log">
<tt class="descname">get_log</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#yaff.pes.ext.Hammer.get_log" title="Permalink to this definition">¶</a></dt>
<dd><p>get_log()</p>
<p>Return a string suitable for the screen logger</p>
</dd></dl>

<dl class="attribute">
<dt id="yaff.pes.ext.Hammer.tau">
<tt class="descname">tau</tt><a class="headerlink" href="#yaff.pes.ext.Hammer.tau" title="Permalink to this definition">¶</a></dt>
<dd><p>Hammer._get_tau(self)
The Tau parameter of the truncation function</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="yaff.pes.ext.Switch3">
<em class="property">class </em><tt class="descclassname">yaff.pes.ext.</tt><tt class="descname">Switch3</tt><a class="headerlink" href="#yaff.pes.ext.Switch3" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.ext.Truncation</span></tt></p>
<p>A simple and good truncation scheme.</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>width</dt>
<dd>The width parameter, <img class="math" src="_images/math/9ee4b825a2e36ae093ed7be5e4851ef453b34914.png" alt="w" style="vertical-align: 0px"/>, in the mathematical expression below.</dd>
</dl>
<p>This is the recommended truncation scheme in Yaff. It has the following
mathematical form:</p>
<div class="math">
<p><img src="_images/math/de05bd4a0096daf798a6e2115ee3ae916a7ecf21.png" alt="t_\text{swithc3}(d) = \left\lbrace \begin{array}{ll}
    1 &amp; \text{if } d &lt; r_\text{cut} - w \\
    3x^2 - 2x^3 &amp; \text{if } d &lt; r_\text{cut} \text{ with } x=\frac{r_\text{cut} - d}{w} \\
    0 &amp; \text{if } d &gt;= r_\text{cut}
\end{array} \right."/></p>
</div><dl class="method">
<dt id="yaff.pes.ext.Switch3.get_log">
<tt class="descname">get_log</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#yaff.pes.ext.Switch3.get_log" title="Permalink to this definition">¶</a></dt>
<dd><p>get_log()</p>
<p>Return a string suitable for the screen logger</p>
</dd></dl>

<dl class="attribute">
<dt id="yaff.pes.ext.Switch3.width">
<tt class="descname">width</tt><a class="headerlink" href="#yaff.pes.ext.Switch3.width" title="Permalink to this definition">¶</a></dt>
<dd><p>Switch3._get_width(self)
The width parameter of the truncation scheme</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="yaff.pes.ext.PairPot">
<em class="property">class </em><tt class="descclassname">yaff.pes.ext.</tt><tt class="descname">PairPot</tt><a class="headerlink" href="#yaff.pes.ext.PairPot" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Base class for the pair potentials</p>
<dl class="method">
<dt id="yaff.pes.ext.PairPot.compute">
<tt class="descname">compute</tt><big>(</big><em>self</em>, <em>ndarray neighs</em>, <em>ndarray stab</em>, <em>ndarray gpos</em>, <em>ndarray vtens</em>, <em>long nneigh</em><big>)</big><a class="headerlink" href="#yaff.pes.ext.PairPot.compute" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the pairwise interactions</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>neighs</dt>
<dd>The neighbor list array. One element is of the datatype
nlist.neigh_row_type.</dd>
<dt>stab</dt>
<dd>The array with short-range scalings. Each element is of the
datatype pair_pot.scaling_row_type</dd>
<dt>gpos</dt>
<dd>The output array for the derivative of the energy towards the
atomic positions. If None, these derivatives are not computed.</dd>
<dt>vtens</dt>
<dd>The output array for the virial tensor. If none, it is not
computed.</dd>
<dt>nneigh</dt>
<dd>The number of records to consider in the neighbor list.</dd>
</dl>
<p><strong>Returns:</strong> the energy.</p>
</dd></dl>

<dl class="method">
<dt id="yaff.pes.ext.PairPot.get_truncation">
<tt class="descname">get_truncation</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#yaff.pes.ext.PairPot.get_truncation" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the current truncation scheme</p>
</dd></dl>

<dl class="attribute">
<dt id="yaff.pes.ext.PairPot.rcut">
<tt class="descname">rcut</tt><a class="headerlink" href="#yaff.pes.ext.PairPot.rcut" title="Permalink to this definition">¶</a></dt>
<dd><p>PairPot._get_rcut(self)
The cutoff parameter</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="yaff.pes.ext.PairPotLJ">
<em class="property">class </em><tt class="descclassname">yaff.pes.ext.</tt><tt class="descname">PairPotLJ</tt><a class="headerlink" href="#yaff.pes.ext.PairPotLJ" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#yaff.pes.ext.PairPot" title="yaff.pes.ext.PairPot"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.ext.PairPot</span></tt></a></p>
<p>Lennard-Jones pair potential:</p>
<p><strong>Energy:</strong></p>
<div class="math">
<p><img src="_images/math/5d589e6dedad57c66af6bcc3835186f7dedaa4b4.png" alt="E_\text{LJ} = \sum_{i=1}^{N} \sum_{j=i+1}^{N} 4 s_{ij} \epsilon_{ij} \left[
\left(\frac{\sigma_{ij}}{d_{ij}}\right)^{12} - \left(\frac{\sigma_{ij}}{d_{ij}}\right)^6
\right]"/></p>
</div><p>with</p>
<div class="math">
<p><img src="_images/math/83eaf38f5fe15d478f65e3e662859fbee02d1972.png" alt="\epsilon_{ij} = \sqrt{\epsilon_i \epsilon_j}"/></p>
</div><div class="math">
<p><img src="_images/math/a2281a6f62772a3c3b57b821ffbdf69f7cc45f1c.png" alt="\sigma_{ij} = \frac{\sigma_i + \sigma_j}{2}"/></p>
</div><div class="math">
<p><img src="_images/math/d234c2f1eeeae460456ee981232df1ec5e4340a6.png" alt="s_{ij} = \text{the short-range scaling factor}"/></p>
</div><p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>sigmas</dt>
<dd>An array with sigma parameters, one for each atom, shape (natom,)</dd>
<dt>epsilons</dt>
<dd>An array with epsilon parameters, one for each atom, shape (natom,)</dd>
<dt>rcut</dt>
<dd>The cutoff radius</dd>
</dl>
<p><strong>Optional arguments:</strong></p>
<dl class="docutils">
<dt>tr</dt>
<dd>The truncation scheme, an instance of a subclass of <tt class="docutils literal"><span class="pre">Truncation</span></tt>.
When not given, no truncation is applied</dd>
</dl>
<dl class="attribute">
<dt id="yaff.pes.ext.PairPotLJ.epsilons">
<tt class="descname">epsilons</tt><a class="headerlink" href="#yaff.pes.ext.PairPotLJ.epsilons" title="Permalink to this definition">¶</a></dt>
<dd><p>PairPotLJ._get_epsilons(self)
The array with epsilon parameters</p>
</dd></dl>

<dl class="method">
<dt id="yaff.pes.ext.PairPotLJ.log">
<tt class="descname">log</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#yaff.pes.ext.PairPotLJ.log" title="Permalink to this definition">¶</a></dt>
<dd><p>Write some suitable post-initialization screen log</p>
</dd></dl>

<dl class="attribute">
<dt id="yaff.pes.ext.PairPotLJ.name">
<tt class="descname">name</tt><em class="property"> = 'lj'</em><a class="headerlink" href="#yaff.pes.ext.PairPotLJ.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="yaff.pes.ext.PairPotLJ.sigmas">
<tt class="descname">sigmas</tt><a class="headerlink" href="#yaff.pes.ext.PairPotLJ.sigmas" title="Permalink to this definition">¶</a></dt>
<dd><p>PairPotLJ._get_sigmas(self)
The array with sigma parameters</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="yaff.pes.ext.PairPotMM3">
<em class="property">class </em><tt class="descclassname">yaff.pes.ext.</tt><tt class="descname">PairPotMM3</tt><a class="headerlink" href="#yaff.pes.ext.PairPotMM3" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#yaff.pes.ext.PairPot" title="yaff.pes.ext.PairPot"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.ext.PairPot</span></tt></a></p>
<p>The MM3 version of the Lennard-Jones pair potential</p>
<p><strong>Energy:</strong></p>
<div class="math">
<p><img src="_images/math/5cba9e52e7fe55dff82440e1032b88bd3a4523cd.png" alt="E_\text{MM3} = \sum_{i=1}^{N} \sum_{j=i+1}^{N} s_{ij} \epsilon_{ij} \left[
1.84\times10^{5} \exp\left(\frac{\sigma_{ij}}{d_{ij}}\right) - 2.25\left(\frac{\sigma_{ij}}{d_{ij}}\right)^6
\right]"/></p>
</div><p>with</p>
<div class="math">
<p><img src="_images/math/83eaf38f5fe15d478f65e3e662859fbee02d1972.png" alt="\epsilon_{ij} = \sqrt{\epsilon_i \epsilon_j}"/></p>
</div><div class="math">
<p><img src="_images/math/a2281a6f62772a3c3b57b821ffbdf69f7cc45f1c.png" alt="\sigma_{ij} = \frac{\sigma_i + \sigma_j}{2}"/></p>
</div><div class="math">
<p><img src="_images/math/d234c2f1eeeae460456ee981232df1ec5e4340a6.png" alt="s_{ij} = \text{the short-range scaling factor}"/></p>
</div><p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>sigmas</dt>
<dd>An array with sigma parameters, one for each atom, shape (natom,)</dd>
<dt>epsilons</dt>
<dd>An array with epsilon parameters, one for each atom, shape (natom,)</dd>
<dt>onlypaulis</dt>
<dd>An array integers. When non-zero for both atoms in a pair, only the
repulsive wall is computed.</dd>
<dt>rcut</dt>
<dd>The cutoff radius</dd>
</dl>
<p><strong>Optional arguments:</strong></p>
<dl class="docutils">
<dt>tr</dt>
<dd>The truncation scheme, an instance of a subclass of <tt class="docutils literal"><span class="pre">Truncation</span></tt>.
When not given, no truncation is applied</dd>
</dl>
<dl class="attribute">
<dt id="yaff.pes.ext.PairPotMM3.epsilons">
<tt class="descname">epsilons</tt><a class="headerlink" href="#yaff.pes.ext.PairPotMM3.epsilons" title="Permalink to this definition">¶</a></dt>
<dd><p>PairPotMM3._get_epsilons(self)
The array with epsilon parameters</p>
</dd></dl>

<dl class="method">
<dt id="yaff.pes.ext.PairPotMM3.log">
<tt class="descname">log</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#yaff.pes.ext.PairPotMM3.log" title="Permalink to this definition">¶</a></dt>
<dd><p>Write some suitable post-initialization screen log</p>
</dd></dl>

<dl class="attribute">
<dt id="yaff.pes.ext.PairPotMM3.name">
<tt class="descname">name</tt><em class="property"> = 'mm3'</em><a class="headerlink" href="#yaff.pes.ext.PairPotMM3.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="yaff.pes.ext.PairPotMM3.onlypaulis">
<tt class="descname">onlypaulis</tt><a class="headerlink" href="#yaff.pes.ext.PairPotMM3.onlypaulis" title="Permalink to this definition">¶</a></dt>
<dd><p>PairPotMM3._get_onlypaulis(self)
The array with the only-Pauli flag</p>
</dd></dl>

<dl class="attribute">
<dt id="yaff.pes.ext.PairPotMM3.sigmas">
<tt class="descname">sigmas</tt><a class="headerlink" href="#yaff.pes.ext.PairPotMM3.sigmas" title="Permalink to this definition">¶</a></dt>
<dd><p>PairPotMM3._get_sigmas(self)
The array with sigma parameters</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="yaff.pes.ext.PairPotGrimme">
<em class="property">class </em><tt class="descclassname">yaff.pes.ext.</tt><tt class="descname">PairPotGrimme</tt><a class="headerlink" href="#yaff.pes.ext.PairPotGrimme" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#yaff.pes.ext.PairPot" title="yaff.pes.ext.PairPot"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.ext.PairPot</span></tt></a></p>
<dl class="attribute">
<dt id="yaff.pes.ext.PairPotGrimme.c6">
<tt class="descname">c6</tt><a class="headerlink" href="#yaff.pes.ext.PairPotGrimme.c6" title="Permalink to this definition">¶</a></dt>
<dd><p>PairPotGrimme._get_c6(self)</p>
</dd></dl>

<dl class="method">
<dt id="yaff.pes.ext.PairPotGrimme.log">
<tt class="descname">log</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#yaff.pes.ext.PairPotGrimme.log" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="yaff.pes.ext.PairPotGrimme.name">
<tt class="descname">name</tt><em class="property"> = 'grimme'</em><a class="headerlink" href="#yaff.pes.ext.PairPotGrimme.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="yaff.pes.ext.PairPotGrimme.r0">
<tt class="descname">r0</tt><a class="headerlink" href="#yaff.pes.ext.PairPotGrimme.r0" title="Permalink to this definition">¶</a></dt>
<dd><p>PairPotGrimme._get_r0(self)</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="yaff.pes.ext.PairPotExpRep">
<em class="property">class </em><tt class="descclassname">yaff.pes.ext.</tt><tt class="descname">PairPotExpRep</tt><a class="headerlink" href="#yaff.pes.ext.PairPotExpRep" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#yaff.pes.ext.PairPot" title="yaff.pes.ext.PairPot"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.ext.PairPot</span></tt></a></p>
<p>Exponential repulsion</p>
<div class="math">
<p><img src="_images/math/9acf1b3e36708df6c937d1e0298521d942a20512.png" alt="E_\text{EXPREP} = \sum_{i=1}^{N} \sum_{j=i+1}^{N} s_{ij} A_{ij} \exp(-B_{ij} d_{ij})"/></p>
</div><p>The pair parameters can be provided explicitly, or can be derived from atomic
parameters using two possible mixing rules for each parameter:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">GEOMETRIC</span></tt> mixing for <img class="math" src="_images/math/9a5722858c4898b558cdf5d74f8d49a29f8a8792.png" alt="A_{ij}" style="vertical-align: -6px"/>: <img class="math" src="_images/math/cf53afa8d21731f5f931760433592a5bfbfa69a8.png" alt="A_{ij} = \sqrt{A_i A_j}" style="vertical-align: -7px"/></li>
<li><tt class="docutils literal"><span class="pre">GEOMETRIC_COR</span></tt> mixing for <img class="math" src="_images/math/9a5722858c4898b558cdf5d74f8d49a29f8a8792.png" alt="A_{ij}" style="vertical-align: -6px"/>: <img class="math" src="_images/math/c2be0fe3c8cbb2f80d6ee3def1aca3d4ad103033.png" alt="\ln A_{ij} = (\ln A_i + \ln A_j)\frac{1-x\vert\ln(A_i/A_j)\vert}{2}" style="vertical-align: -6px"/> where <img class="math" src="_images/math/26eeb5258ca5099acf8fe96b2a1049c48c89a5e6.png" alt="x" style="vertical-align: 0px"/> is a configurable parameter</li>
<li><tt class="docutils literal"><span class="pre">ARITHMETIC</span></tt> mixing for <img class="math" src="_images/math/3bebd804f3ecbe1666953ce90f68e92eff8cf232.png" alt="B_{ij}" style="vertical-align: -6px"/>: <img class="math" src="_images/math/e8be322d6f0f7c3a39a41d6e1a5d6f38cb2aa241.png" alt="B_{ij} = \frac{B_i + B_j}{2}" style="vertical-align: -6px"/></li>
<li><tt class="docutils literal"><span class="pre">ARITHMETIC_COR</span></tt> mixing for <img class="math" src="_images/math/3bebd804f3ecbe1666953ce90f68e92eff8cf232.png" alt="B_{ij}" style="vertical-align: -6px"/>: <img class="math" src="_images/math/b94e73145a2fe870852752e0edb1cec91ca7c3aa.png" alt="B_{ij} = (B_i + B_j)\frac{1-x\vert\ln(A_i/A_j)\vert}{2}" style="vertical-align: -6px"/> where <img class="math" src="_images/math/26eeb5258ca5099acf8fe96b2a1049c48c89a5e6.png" alt="x" style="vertical-align: 0px"/> is a configurable parameter</li>
</ul>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>ffatype_ids</dt>
<dd>An array with atom type IDs for each atom. The IDs are integer
indexes for the atom types that start counting from zero. shape =
(natom,).</dd>
<dt>amp_cross</dt>
<dd>A 2D array of amplitude cross parameters (<img class="math" src="_images/math/9a5722858c4898b558cdf5d74f8d49a29f8a8792.png" alt="A_{ij}" style="vertical-align: -6px"/>)</dd>
<dt>b_cross</dt>
<dd>A 2D array of decay cross parameters (<img class="math" src="_images/math/3bebd804f3ecbe1666953ce90f68e92eff8cf232.png" alt="B_{ij}" style="vertical-align: -6px"/>)</dd>
<dt>rcut</dt>
<dd>The cutoff radius</dd>
</dl>
<p><strong>Optional arguments:</strong></p>
<dl class="docutils">
<dt>tr</dt>
<dd>The truncation scheme, an instance of a subclass of <tt class="docutils literal"><span class="pre">Truncation</span></tt>.
When not given, no truncation is applied</dd>
<dt>amps</dt>
<dd>A 1D array of amplitude diagonal parameters (<img class="math" src="_images/math/a4b24599915694a978e8e1b92ef6b68e3afe1859.png" alt="A_{i}" style="vertical-align: -3px"/>)</dd>
<dt>amp_mix</dt>
<dd>An integer ID that determines the mixing rule for the a parameter.
0=GEOMETRIC, 1=GEOMETRIC_COR.</dd>
<dt>amp_mix_coeff</dt>
<dd>The parameter <img class="math" src="_images/math/26eeb5258ca5099acf8fe96b2a1049c48c89a5e6.png" alt="x" style="vertical-align: 0px"/> for the corrected geometric mixing rule.</dd>
<dt>bs</dt>
<dd>A 1D array of decay diagonal parameters (<img class="math" src="_images/math/dd4e5f5f80ad202ae33b8295d1ce51438005f067.png" alt="B_{i}" style="vertical-align: -3px"/>)</dd>
<dt>b_mix</dt>
<dd>An integer ID that determines the mixing rule for the B parameter.
0=ARITHMETIC, 1=ARITHMETIC_COR.</dd>
<dt>b_mix_coeff</dt>
<dd>The parameter <img class="math" src="_images/math/26eeb5258ca5099acf8fe96b2a1049c48c89a5e6.png" alt="x" style="vertical-align: 0px"/> for the corrected arithmetic mixing rule.</dd>
</dl>
<p>The mixing rules are only in effect when the optional diagonal
parameters are given. Only when the cross parameters are zero (in the
arguments <tt class="docutils literal"><span class="pre">amp_cross</span></tt> and <tt class="docutils literal"><span class="pre">b_cross</span></tt>), these numbers would be
overwritten by the mixing rules.</p>
<dl class="attribute">
<dt id="yaff.pes.ext.PairPotExpRep.amp_cross">
<tt class="descname">amp_cross</tt><a class="headerlink" href="#yaff.pes.ext.PairPotExpRep.amp_cross" title="Permalink to this definition">¶</a></dt>
<dd><p>PairPotExpRep._get_amp_cross(self)
The amplitude cross parameters</p>
</dd></dl>

<dl class="attribute">
<dt id="yaff.pes.ext.PairPotExpRep.b_cross">
<tt class="descname">b_cross</tt><a class="headerlink" href="#yaff.pes.ext.PairPotExpRep.b_cross" title="Permalink to this definition">¶</a></dt>
<dd><p>PairPotExpRep._get_b_cross(self)
The decay cross parameters</p>
</dd></dl>

<dl class="method">
<dt id="yaff.pes.ext.PairPotExpRep.log">
<tt class="descname">log</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#yaff.pes.ext.PairPotExpRep.log" title="Permalink to this definition">¶</a></dt>
<dd><p>Print suitable initialization info on screen.</p>
</dd></dl>

<dl class="attribute">
<dt id="yaff.pes.ext.PairPotExpRep.name">
<tt class="descname">name</tt><em class="property"> = 'exprep'</em><a class="headerlink" href="#yaff.pes.ext.PairPotExpRep.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="yaff.pes.ext.PairPotDampDisp">
<em class="property">class </em><tt class="descclassname">yaff.pes.ext.</tt><tt class="descname">PairPotDampDisp</tt><a class="headerlink" href="#yaff.pes.ext.PairPotDampDisp" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#yaff.pes.ext.PairPot" title="yaff.pes.ext.PairPot"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.ext.PairPot</span></tt></a></p>
<p>Damped dispersion interaction</p>
<p><strong>Energy:</strong></p>
<div class="math">
<p><img src="_images/math/54cbd8d4043fa651327edb487589db49ab8313ba.png" alt="E_\text{DAMPDISP} = \sum_{i=1}^{N} \sum_{j=i+1}^{N} s_{ij} C_{6,ij} f_\text{damp,6}(d_{ij}) d_{ij}^{-6}"/></p>
</div><p>where the damping factor <img class="math" src="_images/math/b1f55e1608251ac696f8c7aa0b83ab76b4feaa00.png" alt="f_\text{damp}(d_{ij})" style="vertical-align: -6px"/> is optional. When used
it has the Tang-Toennies form:</p>
<div class="math">
<p><img src="_images/math/9d865d7a28d7ea0febf4effb8e7532d7dcbf852e.png" alt="f_\text{damp,n}(d_{ij}) = 1 - \exp(-B_{ij}r)\sum_{k=0}^n\frac{(B_{ij}r)^k}{k!}"/></p>
</div><p>The pair parameters <img class="math" src="_images/math/24e9b494adf724e747415726d47d9e2550302b2b.png" alt="C_{6,ij}" style="vertical-align: -6px"/> and <img class="math" src="_images/math/3bebd804f3ecbe1666953ce90f68e92eff8cf232.png" alt="B_{ij}" style="vertical-align: -6px"/> are derived from atomic
parameters using mixing rules, unless they are provided explicitly for a given
pair of atom types. These are the mixing rules:</p>
<div class="math">
<p><img src="_images/math/9c1476b74fac41fe5042219124e5893caa6b9ca0.png" alt="C_{6,ij} = \frac{2 C_{6,i} C_{6,j}}{\left(\frac{V_j}{V_i}\right)^2 C_{6,i} + \left(\frac{V_i}{V_j}\right)^2 C_{6,j}}"/></p>
</div><div class="math">
<p><img src="_images/math/9a7edfef1af700bdedc7e20cb81c76e0b194b42b.png" alt="B_{ij} = \frac{B_i+B_j}{2}"/></p>
</div><p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>ffatype_ids</dt>
<dd>An array with atom type IDs for each atom. The IDs are integer
indexes for the atom types that start counting from zero. shape =
(natom,).</dd>
<dt>c6_cross</dt>
<dd>The <img class="math" src="_images/math/24e9b494adf724e747415726d47d9e2550302b2b.png" alt="C_{6,ij}" style="vertical-align: -6px"/> cross parameters.</dd>
<dt>b_cross</dt>
<dd>The <img class="math" src="_images/math/3bebd804f3ecbe1666953ce90f68e92eff8cf232.png" alt="B_{ij}" style="vertical-align: -6px"/> cross parameters. When zero, the damping factor
is set to one.</dd>
<dt>rcut</dt>
<dd>The cutoff radius</dd>
</dl>
<p><strong>Optional arguments:</strong></p>
<dl class="docutils">
<dt>tr</dt>
<dd>The truncation scheme, an instance of a subclass of <tt class="docutils literal"><span class="pre">Truncation</span></tt>.
When not given, no truncation is applied</dd>
<dt>c6s</dt>
<dd>The diagonal <img class="math" src="_images/math/c0dcfe701b93aec1da49b310d7e4a9cf529b56df.png" alt="C_{6,i}" style="vertical-align: -6px"/> parameters</dd>
<dt>bs</dt>
<dd>The diagonal <img class="math" src="_images/math/dd4e5f5f80ad202ae33b8295d1ce51438005f067.png" alt="B_{i}" style="vertical-align: -3px"/> parameters</dd>
<dt>vols</dt>
<dd>The atomic volumes, <img class="math" src="_images/math/eed415fecae2ca4477fa58c7d570aa39facec00f.png" alt="V_i" style="vertical-align: -3px"/>.</dd>
</dl>
<p>The three last optional arguments are used to determine pair parameters
from the mixing rules. These mixing rules are only applied of the
corresponding cross parameters are initially set to zero in the arrays
<tt class="docutils literal"><span class="pre">c6_corss</span></tt> and <tt class="docutils literal"><span class="pre">b_cross</span></tt>.</p>
<dl class="attribute">
<dt id="yaff.pes.ext.PairPotDampDisp.b_cross">
<tt class="descname">b_cross</tt><a class="headerlink" href="#yaff.pes.ext.PairPotDampDisp.b_cross" title="Permalink to this definition">¶</a></dt>
<dd><p>PairPotDampDisp._get_b_cross(self)
The damping cross parameters</p>
</dd></dl>

<dl class="attribute">
<dt id="yaff.pes.ext.PairPotDampDisp.c6_cross">
<tt class="descname">c6_cross</tt><a class="headerlink" href="#yaff.pes.ext.PairPotDampDisp.c6_cross" title="Permalink to this definition">¶</a></dt>
<dd><p>PairPotDampDisp._get_c6_cross(self)
The C6 cross parameters</p>
</dd></dl>

<dl class="method">
<dt id="yaff.pes.ext.PairPotDampDisp.log">
<tt class="descname">log</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#yaff.pes.ext.PairPotDampDisp.log" title="Permalink to this definition">¶</a></dt>
<dd><p>Print suitable initialization info on screen.</p>
</dd></dl>

<dl class="attribute">
<dt id="yaff.pes.ext.PairPotDampDisp.name">
<tt class="descname">name</tt><em class="property"> = 'dampdisp'</em><a class="headerlink" href="#yaff.pes.ext.PairPotDampDisp.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="yaff.pes.ext.PairPotEI">
<em class="property">class </em><tt class="descclassname">yaff.pes.ext.</tt><tt class="descname">PairPotEI</tt><a class="headerlink" href="#yaff.pes.ext.PairPotEI" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#yaff.pes.ext.PairPot" title="yaff.pes.ext.PairPot"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.ext.PairPot</span></tt></a></p>
<p>Short-range contribution to the electrostatic interaction between point charges</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>charges</dt>
<dd>An array of atomic charges, shape = (natom,)</dd>
<dt>alpha</dt>
<dd>The <img class="math" src="_images/math/10f32377ac67d94f764f12a15ea987e88c85d3e1.png" alt="\alpha" style="vertical-align: 0px"/> parameter in the Ewald summation scheme. When
set to zero, the interaction between point charges is computed
without any long-range screening.</dd>
<dt>rcut</dt>
<dd>The cutoff radius</dd>
</dl>
<p><strong>Optional arguments:</strong></p>
<dl class="docutils">
<dt>tr</dt>
<dd>The truncation scheme, an instance of a subclass of <tt class="docutils literal"><span class="pre">Truncation</span></tt>.
When not given, no truncation is applied</dd>
<dt>dielectric</dt>
<dd>A relative dielectric permitivity that just scales the Coulomb
interaction.</dd>
<dt>radii</dt>
<dd>An array of atomic radii, shape = (natom,). The charge distribution
of atom <img class="math" src="_images/math/34857b3ba74ce5cd8607f3ebd23e9015908ada71.png" alt="i" style="vertical-align: 0px"/> with radius <img class="math" src="_images/math/96c42077f2a447ca548cdbfe63f1932e9866df3a.png" alt="r_i" style="vertical-align: -3px"/> centered at <img class="math" src="_images/math/2530740b005338f01b5cd8b73d53b1e97a017759.png" alt="\mathbf{R}_i" style="vertical-align: -3px"/>
is of a Gaussian shape:
<img class="math" src="_images/math/4e87bc91b8e1d0089a8933ed70144441558c42a4.png" alt="\rho_i (\mathbf{r}) = q_i\left(\frac{1}{\pi r_i^2}\right)^{3/2} \exp{-\frac{|\mathbf{r} -\mathbf{R}_i |^2}{r_i^2}}" style="vertical-align: -13px"/>
When the atomic radius equals zero, the charge distribution becomes a
point monopole.
Only implemented for non-periodic systems</dd>
</dl>
<dl class="attribute">
<dt id="yaff.pes.ext.PairPotEI.alpha">
<tt class="descname">alpha</tt><a class="headerlink" href="#yaff.pes.ext.PairPotEI.alpha" title="Permalink to this definition">¶</a></dt>
<dd><p>PairPotEI._get_alpha(self)
The alpha parameter in the Ewald summation method</p>
</dd></dl>

<dl class="attribute">
<dt id="yaff.pes.ext.PairPotEI.charges">
<tt class="descname">charges</tt><a class="headerlink" href="#yaff.pes.ext.PairPotEI.charges" title="Permalink to this definition">¶</a></dt>
<dd><p>PairPotEI._get_charges(self)
The atomic charges</p>
</dd></dl>

<dl class="attribute">
<dt id="yaff.pes.ext.PairPotEI.dielectric">
<tt class="descname">dielectric</tt><a class="headerlink" href="#yaff.pes.ext.PairPotEI.dielectric" title="Permalink to this definition">¶</a></dt>
<dd><p>PairPotEI._get_dielectric(self)
The scalar relative permittivity</p>
</dd></dl>

<dl class="method">
<dt id="yaff.pes.ext.PairPotEI.log">
<tt class="descname">log</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#yaff.pes.ext.PairPotEI.log" title="Permalink to this definition">¶</a></dt>
<dd><p>Print suitable initialization info on screen.</p>
</dd></dl>

<dl class="attribute">
<dt id="yaff.pes.ext.PairPotEI.name">
<tt class="descname">name</tt><em class="property"> = 'ei'</em><a class="headerlink" href="#yaff.pes.ext.PairPotEI.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="yaff.pes.ext.PairPotEI.radii">
<tt class="descname">radii</tt><a class="headerlink" href="#yaff.pes.ext.PairPotEI.radii" title="Permalink to this definition">¶</a></dt>
<dd><p>PairPotEI._get_radii(self)
The atomic radii</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="yaff.pes.ext.PairPotEIDip">
<em class="property">class </em><tt class="descclassname">yaff.pes.ext.</tt><tt class="descname">PairPotEIDip</tt><a class="headerlink" href="#yaff.pes.ext.PairPotEIDip" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#yaff.pes.ext.PairPot" title="yaff.pes.ext.PairPot"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.ext.PairPot</span></tt></a></p>
<p>Short-range contribution to the electrostatic interaction between point charges
and point dipoles. Only works for non-periodic systems and without truncation scheme</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>charges</dt>
<dd>An array of atomic charges, shape = (natom,)</dd>
<dt>dipoles</dt>
<dd>An array of atomic point dipoles, shape = (natom,3)</dd>
<dt>poltens_i</dt>
<dd>An array that gives the inverse atomic polarizabilities, shape = (3natom, 3)</dd>
</dl>
<p>TODO: What about other parameters, for example from EEM? More general way
to include necessary parameters.</p>
<p><strong>Optional arguments:</strong></p>
<dl class="docutils">
<dt>tr</dt>
<dd>The truncation scheme, an instance of a subclass of <tt class="docutils literal"><span class="pre">Truncation</span></tt>.
When not given, no truncation is applied</dd>
</dl>
<dl class="attribute">
<dt id="yaff.pes.ext.PairPotEIDip.alpha">
<tt class="descname">alpha</tt><a class="headerlink" href="#yaff.pes.ext.PairPotEIDip.alpha" title="Permalink to this definition">¶</a></dt>
<dd><p>PairPotEIDip._get_alpha(self)
The alpha parameter in the Ewald summation method</p>
</dd></dl>

<dl class="attribute">
<dt id="yaff.pes.ext.PairPotEIDip.charges">
<tt class="descname">charges</tt><a class="headerlink" href="#yaff.pes.ext.PairPotEIDip.charges" title="Permalink to this definition">¶</a></dt>
<dd><p>PairPotEIDip._get_charges(self)
The atomic charges</p>
</dd></dl>

<dl class="method">
<dt id="yaff.pes.ext.PairPotEIDip.compute">
<tt class="descname">compute</tt><big>(</big><em>self</em>, <em>ndarray neighs</em>, <em>ndarray stab</em>, <em>ndarray gpos</em>, <em>ndarray vtens</em>, <em>long nneigh</em><big>)</big><a class="headerlink" href="#yaff.pes.ext.PairPotEIDip.compute" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="yaff.pes.ext.PairPotEIDip.dipoles">
<tt class="descname">dipoles</tt><a class="headerlink" href="#yaff.pes.ext.PairPotEIDip.dipoles" title="Permalink to this definition">¶</a></dt>
<dd><p>PairPotEIDip._get_dipoles(self)
The atomic charges</p>
</dd></dl>

<dl class="method">
<dt id="yaff.pes.ext.PairPotEIDip.log">
<tt class="descname">log</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#yaff.pes.ext.PairPotEIDip.log" title="Permalink to this definition">¶</a></dt>
<dd><p>Print suitable initialization info on screen.</p>
</dd></dl>

<dl class="attribute">
<dt id="yaff.pes.ext.PairPotEIDip.name">
<tt class="descname">name</tt><em class="property"> = 'eidip'</em><a class="headerlink" href="#yaff.pes.ext.PairPotEIDip.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="yaff.pes.ext.PairPotEIDip.poltens_i">
<tt class="descname">poltens_i</tt><a class="headerlink" href="#yaff.pes.ext.PairPotEIDip.poltens_i" title="Permalink to this definition">¶</a></dt>
<dd><p>PairPotEIDip._get_poltens_i(self)
The atomic charges</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="yaff.pes.ext.compute_ewald_reci">
<tt class="descclassname">yaff.pes.ext.</tt><tt class="descname">compute_ewald_reci</tt><big>(</big><em>ndarray pos</em>, <em>ndarray charges</em>, <em>Cell unitcell</em>, <em>double alpha</em>, <em>ndarray gmax</em>, <em>double gcut</em>, <em>double dielectric</em>, <em>ndarray gpos</em>, <em>ndarray work</em>, <em>ndarray vtens</em><big>)</big><a class="headerlink" href="#yaff.pes.ext.compute_ewald_reci" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the reciprocal interaction term in the Ewald summation scheme</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>pos</dt>
<dd>The atomic positions. numpy array with shape (natom,3).</dd>
<dt>charges</dt>
<dd>The atomic charges. numpy array with shape (natom,).</dd>
<dt>unitcell</dt>
<dd>An instance of the <tt class="docutils literal"><span class="pre">Cell</span></tt> class that describes the periodic
boundary conditions.</dd>
<dt>alpha</dt>
<dd>The <img class="math" src="_images/math/10f32377ac67d94f764f12a15ea987e88c85d3e1.png" alt="\alpha" style="vertical-align: 0px"/> parameter from the Ewald summation scheme.</dd>
<dt>gmax</dt>
<dd>The maximum range of periodic images in reciprocal space to be
considered for the Ewald sum. integer numpy array with shape (3,).
Each element gives the range along the corresponding reciprocal
cell vector. The range along each axis goes from -gmax[0] to
gmax[0] (inclusive).</dd>
<dt>gcut</dt>
<dd>The cutoff in reciprocal space. The caller is responsible for the
compatibility of <tt class="docutils literal"><span class="pre">gcut</span></tt> with <tt class="docutils literal"><span class="pre">gmax</span></tt>.</dd>
<dt>dielectric</dt>
<dd>The scalar relative permittivity of the system.</dd>
<dt>gpos</dt>
<dd>If not set to None, the Cartesian gradient of the energy is
stored in this array. numpy array with shape (natom, 3).</dd>
<dt>work</dt>
<dd>If gpos is given, this work array must also be present. Its
contents will be overwritten. numpy array with shape (2*natom,).</dd>
<dt>vtens</dt>
<dd>If not set to None, the virial tensor is computed and stored in
this array. numpy array with shape (3, 3).</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yaff.pes.ext.compute_ewald_reci_dd">
<tt class="descclassname">yaff.pes.ext.</tt><tt class="descname">compute_ewald_reci_dd</tt><big>(</big><em>ndarray pos</em>, <em>ndarray charges</em>, <em>ndarray dipoles</em>, <em>Cell unitcell</em>, <em>double alpha</em>, <em>ndarray gmax</em>, <em>double gcut</em>, <em>ndarray gpos</em>, <em>ndarray work</em>, <em>ndarray vtens</em><big>)</big><a class="headerlink" href="#yaff.pes.ext.compute_ewald_reci_dd" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the reciprocal interaction term in the Ewald summation scheme</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>pos</dt>
<dd>The atomic positions. numpy array with shape (natom,3).</dd>
<dt>charges</dt>
<dd>The atomic charges. numpy array with shape (natom,).</dd>
<dt>dipoles</dt>
<dd>The atomic dipoles. numpy array with shape (natom,3).</dd>
<dt>unitcell</dt>
<dd>An instance of the <tt class="docutils literal"><span class="pre">Cell</span></tt> class that describes the periodic
boundary conditions.</dd>
<dt>alpha</dt>
<dd>The <img class="math" src="_images/math/10f32377ac67d94f764f12a15ea987e88c85d3e1.png" alt="\alpha" style="vertical-align: 0px"/> parameter from the Ewald summation scheme.</dd>
<dt>gmax</dt>
<dd>The maximum range of periodic images in reciprocal space to be
considered for the Ewald sum. integer numpy array with shape (3,).
Each element gives the range along the corresponding reciprocal
cell vector. The range along each axis goes from -gmax[0] to
gmax[0] (inclusive).</dd>
<dt>gcut</dt>
<dd>The cutoff in reciprocal space. The caller is responsible for the
compatibility of <tt class="docutils literal"><span class="pre">gcut</span></tt> with <tt class="docutils literal"><span class="pre">gmax</span></tt>.</dd>
<dt>gpos</dt>
<dd>If not set to None, the Cartesian gradient of the energy is
stored in this array. numpy array with shape (natom, 3).</dd>
<dt>work</dt>
<dd>If gpos is given, this work array must also be present. Its
contents will be overwritten. numpy array with shape (2*natom,).</dd>
<dt>vtens</dt>
<dd>If not set to None, the virial tensor is computed and stored in
this array. numpy array with shape (3, 3).</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yaff.pes.ext.compute_ewald_corr_dd">
<tt class="descclassname">yaff.pes.ext.</tt><tt class="descname">compute_ewald_corr_dd</tt><big>(</big><em>ndarray pos</em>, <em>ndarray charges</em>, <em>ndarray dipoles</em>, <em>Cell unitcell</em>, <em>double alpha</em>, <em>ndarray stab</em>, <em>ndarray gpos</em>, <em>ndarray vtens</em><big>)</big><a class="headerlink" href="#yaff.pes.ext.compute_ewald_corr_dd" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the corrections to the reciprocal Ewald term due to scaled
short-range non-bonding interactions.</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>pos</dt>
<dd>The atomic positions. numpy array with shape (natom,3).</dd>
<dt>charges</dt>
<dd>The atomic charges. numpy array with shape (natom,).</dd>
<dt>unitcell</dt>
<dd>An instance of the <tt class="docutils literal"><span class="pre">Cell</span></tt> class that describes the periodic
boundary conditions.</dd>
<dt>alpha</dt>
<dd>The <img class="math" src="_images/math/10f32377ac67d94f764f12a15ea987e88c85d3e1.png" alt="\alpha" style="vertical-align: 0px"/> parameter from the Ewald summation scheme.</dd>
<dt>stab</dt>
<dd>The table with (sorted) pairs of atoms whose electrostatic
interactions are scaled. Each record corresponds to one pair
and contains the corresponding amount of scaling. See
<tt class="docutils literal"><span class="pre">pair_pot.scaling_row_type</span></tt></dd>
<dt>gpos</dt>
<dd>If not set to None, the Cartesian gradient of the energy is
stored in this array. numpy array with shape (natom, 3).</dd>
<dt>vtens</dt>
<dd>If not set to None, the virial tensor is computed and stored in
this array. numpy array with shape (3, 3).</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yaff.pes.ext.compute_ewald_corr">
<tt class="descclassname">yaff.pes.ext.</tt><tt class="descname">compute_ewald_corr</tt><big>(</big><em>ndarray pos</em>, <em>ndarray charges</em>, <em>Cell unitcell</em>, <em>double alpha</em>, <em>ndarray stab</em>, <em>double dielectric</em>, <em>ndarray gpos</em>, <em>ndarray vtens</em><big>)</big><a class="headerlink" href="#yaff.pes.ext.compute_ewald_corr" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the corrections to the reciprocal Ewald term due to scaled
short-range non-bonding interactions.</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>pos</dt>
<dd>The atomic positions. numpy array with shape (natom,3).</dd>
<dt>charges</dt>
<dd>The atomic charges. numpy array with shape (natom,).</dd>
<dt>unitcell</dt>
<dd>An instance of the <tt class="docutils literal"><span class="pre">Cell</span></tt> class that describes the periodic
boundary conditions.</dd>
<dt>alpha</dt>
<dd>The <img class="math" src="_images/math/10f32377ac67d94f764f12a15ea987e88c85d3e1.png" alt="\alpha" style="vertical-align: 0px"/> parameter from the Ewald summation scheme.</dd>
<dt>stab</dt>
<dd>The table with (sorted) pairs of atoms whose electrostatic
interactions are scaled. Each record corresponds to one pair
and contains the corresponding amount of scaling. See
<tt class="docutils literal"><span class="pre">pair_pot.scaling_row_type</span></tt></dd>
<dt>dielectric</dt>
<dd>The scalar relative permittivity of the system.</dd>
<dt>gpos</dt>
<dd>If not set to None, the Cartesian gradient of the energy is
stored in this array. numpy array with shape (natom, 3).</dd>
<dt>vtens</dt>
<dd>If not set to None, the virial tensor is computed and stored in
this array. numpy array with shape (3, 3).</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yaff.pes.ext.dlist_forward">
<tt class="descclassname">yaff.pes.ext.</tt><tt class="descname">dlist_forward</tt><big>(</big><em>ndarray pos</em>, <em>Cell unitcell</em>, <em>ndarray deltas</em>, <em>long ndelta</em><big>)</big><a class="headerlink" href="#yaff.pes.ext.dlist_forward" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the relative vectors in the delta list</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>pos</dt>
<dd>The atomic positions. numpy array with shape (natom,3).</dd>
<dt>unitcell</dt>
<dd>An instance of the <tt class="docutils literal"><span class="pre">Cell</span></tt> class that describes the periodic
boundary conditions.</dd>
<dt>deltas</dt>
<dd>The delta list array</dd>
<dt>ndelta</dt>
<dd>The number of records in the delta list that need to be computed.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yaff.pes.ext.dlist_back">
<tt class="descclassname">yaff.pes.ext.</tt><tt class="descname">dlist_back</tt><big>(</big><em>ndarray gpos</em>, <em>ndarray vtens</em>, <em>ndarray deltas</em>, <em>long ndelta</em><big>)</big><a class="headerlink" href="#yaff.pes.ext.dlist_back" title="Permalink to this definition">¶</a></dt>
<dd><p>The back-propagation step of the delta list</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>gpos</dt>
<dd>If not set to None, the Cartesian gradient of the energy is
stored in this array. numpy array with shape (natom, 3).</dd>
<dt>vtens</dt>
<dd>If not set to None, the virial tensor is computed and stored in
this array. numpy array with shape (3, 3).</dd>
<dt>deltas</dt>
<dd>The delta list array</dd>
<dt>ndelta</dt>
<dd>The number of records in the delta list that need to be computed.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yaff.pes.ext.iclist_forward">
<tt class="descclassname">yaff.pes.ext.</tt><tt class="descname">iclist_forward</tt><big>(</big><em>ndarray deltas</em>, <em>ndarray ictab</em>, <em>long nic</em><big>)</big><a class="headerlink" href="#yaff.pes.ext.iclist_forward" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute internal coordinates based on relative vectors</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>deltas</dt>
<dd>The delta list array (input)</dd>
<dt>ictab</dt>
<dd>The table with internal coordinates that must be computed (input and
output).</dd>
<dt>nic</dt>
<dd>The number of records in the <tt class="docutils literal"><span class="pre">ictab</span></tt> array to compute.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yaff.pes.ext.iclist_back">
<tt class="descclassname">yaff.pes.ext.</tt><tt class="descname">iclist_back</tt><big>(</big><em>ndarray deltas</em>, <em>ndarray ictab</em>, <em>long nic</em><big>)</big><a class="headerlink" href="#yaff.pes.ext.iclist_back" title="Permalink to this definition">¶</a></dt>
<dd><p>The back-propagation step in the internal coordinate list</p>
<dl class="docutils">
<dt>deltas</dt>
<dd>The delta list array (output)</dd>
<dt>ictab</dt>
<dd>The table with internal coordinates that must be computed (input).</dd>
<dt>nic</dt>
<dd>The number of records in the <tt class="docutils literal"><span class="pre">ictab</span></tt> array to compute.</dd>
</dl>
<p>This routine transforms the partial derivatives of the energy towards the
internal coordinates, stored in <tt class="docutils literal"><span class="pre">ictab</span></tt>, into partial derivatives of
the energy towards relative vectors, added to <tt class="docutils literal"><span class="pre">deltas</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="yaff.pes.ext.vlist_forward">
<tt class="descclassname">yaff.pes.ext.</tt><tt class="descname">vlist_forward</tt><big>(</big><em>ndarray ictab</em>, <em>ndarray vtab</em>, <em>long nv</em><big>)</big><a class="headerlink" href="#yaff.pes.ext.vlist_forward" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes valence energy terms based on a list of internal coordinates</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>ictab</dt>
<dd>The table with internal coordinates (input).</dd>
<dt>vtab</dt>
<dd>The table with covalent energy terms (input and output).</dd>
<dt>nv</dt>
<dd>The number of records to consider in <tt class="docutils literal"><span class="pre">vtab</span></tt>.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="yaff.pes.ext.vlist_back">
<tt class="descclassname">yaff.pes.ext.</tt><tt class="descname">vlist_back</tt><big>(</big><em>ndarray ictab</em>, <em>ndarray vtab</em>, <em>long nv</em><big>)</big><a class="headerlink" href="#yaff.pes.ext.vlist_back" title="Permalink to this definition">¶</a></dt>
<dd><p>The back-propagation step in the valence list.</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>ictab</dt>
<dd>The table with internal coordinates (output).</dd>
<dt>vtab</dt>
<dd>The table with covalent energy terms (input).</dd>
<dt>nv</dt>
<dd>The number of records to consider in <tt class="docutils literal"><span class="pre">vtab</span></tt>.</dd>
</dl>
<p>This routine computes the derivatives of the energy of each term towards
the internal coordinates and adds the results to the <tt class="docutils literal"><span class="pre">ictab</span></tt> array.</p>
</dd></dl>

<dl class="function">
<dt id="yaff.pes.ext.compute_grid3d">
<tt class="descclassname">yaff.pes.ext.</tt><tt class="descname">compute_grid3d</tt><big>(</big><em>ndarray center</em>, <em>Cell unitcell</em>, <em>ndarray egrid</em><big>)</big><a class="headerlink" href="#yaff.pes.ext.compute_grid3d" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-yaff.pes.ff">
<span id="yaff-pes-ff-force-field-models"></span><h2>2.3. <tt class="docutils literal"><span class="pre">yaff.pes.ff</span></tt> &#8211; Force field models<a class="headerlink" href="#module-yaff.pes.ff" title="Permalink to this headline">¶</a></h2>
<p>Force field models</p>
<p>This module contains the force field computation interface that is used by
the <tt class="xref py py-mod docutils literal"><span class="pre">yaff.sampling</span></tt> package.</p>
<p>The <tt class="docutils literal"><span class="pre">ForceField</span></tt> class is the main item in this module. It acts as
container for instances of subclasses of <tt class="docutils literal"><span class="pre">ForcePart</span></tt>. Each <tt class="docutils literal"><span class="pre">ForcePart</span></tt>
subclass implements a typical contribution to the force field energy, e.g.
<tt class="docutils literal"><span class="pre">ForcePartValence</span></tt> computes covalent interactions, <tt class="docutils literal"><span class="pre">ForcePartPair</span></tt>
computes pairwise (non-bonding) interactions, and so on. The <tt class="docutils literal"><span class="pre">ForceField</span></tt>
object also contains one neighborlist object, which is used by all
<tt class="docutils literal"><span class="pre">ForcePartPair</span></tt> objects. Actual computations are done through the
<tt class="docutils literal"><span class="pre">compute</span></tt> method of the <tt class="docutils literal"><span class="pre">ForceField</span></tt> object, which calls the <tt class="docutils literal"><span class="pre">compute</span></tt>
method of all the <tt class="docutils literal"><span class="pre">ForceParts</span></tt> and adds up the results.</p>
<dl class="class">
<dt id="yaff.pes.ff.ForcePart">
<em class="property">class </em><tt class="descclassname">yaff.pes.ff.</tt><tt class="descname">ForcePart</tt><big>(</big><em>name</em>, <em>system</em><big>)</big><a class="headerlink" href="#yaff.pes.ff.ForcePart" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Base class for anything that can compute energies (and optionally gradient
and virial) for a <tt class="docutils literal"><span class="pre">System</span></tt> object.</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>name</dt>
<dd>A name for this part of the force field. This name must adhere
to the following conventions: all lower case, no white space,
and short. It is used to construct part_* attributes in the
ForceField class, where * is the name.</dd>
<dt>system</dt>
<dd>The system to which this part of the FF applies.</dd>
</dl>
<dl class="method">
<dt id="yaff.pes.ff.ForcePart.clear">
<tt class="descname">clear</tt><big>(</big><big>)</big><a class="headerlink" href="#yaff.pes.ff.ForcePart.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill in nan values in the cached results to indicate that they have
become invalid.</p>
</dd></dl>

<dl class="method">
<dt id="yaff.pes.ff.ForcePart.compute">
<tt class="descname">compute</tt><big>(</big><em>gpos=None</em>, <em>vtens=None</em><big>)</big><a class="headerlink" href="#yaff.pes.ff.ForcePart.compute" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the energy and optionally some derivatives for this FF (part)</p>
<p>The only variable inputs for the compute routine are the atomic
positions and the cell vectors, which can be changed through the
<tt class="docutils literal"><span class="pre">update_rvecs</span></tt> and <tt class="docutils literal"><span class="pre">update_pos</span></tt> methods. All other aspects of
a force field are considered to be fixed between subsequent compute
calls. If changes other than positions or cell vectors are needed,
one must construct new <tt class="docutils literal"><span class="pre">ForceField</span></tt> and/or <tt class="docutils literal"><span class="pre">ForcePart</span></tt> objects.</p>
<p><strong>Optional arguments:</strong></p>
<dl class="docutils">
<dt>gpos</dt>
<dd>The derivatives of the energy towards the Cartesian coordinates
of the atoms. (&#8216;g&#8217; stands for gradient and &#8216;pos&#8217; for positions.)
This must be a writeable numpy array with shape (N, 3) where N
is the number of atoms.</dd>
<dt>vtens</dt>
<dd>The force contribution to the pressure tensor. This is also
known as the virial tensor. It represents the derivative of the
energy towards uniform deformations, including changes in the
shape of the unit cell. (v stands for virial and &#8216;tens&#8217; stands
for tensor.) This must be a writeable numpy array with shape (3,
3).</dd>
</dl>
<p>The energy is returned. The optional arguments are Fortran-style
output arguments. When they are present, the corresponding results
are computed and <strong>added</strong> to the current contents of the array.</p>
</dd></dl>

<dl class="method">
<dt id="yaff.pes.ff.ForcePart.update_pos">
<tt class="descname">update_pos</tt><big>(</big><em>pos</em><big>)</big><a class="headerlink" href="#yaff.pes.ff.ForcePart.update_pos" title="Permalink to this definition">¶</a></dt>
<dd><p>Let the <tt class="docutils literal"><span class="pre">ForcePart</span></tt> object know that the atomic positions have changed.</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>pos</dt>
<dd>The new atomic coordinates.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="yaff.pes.ff.ForcePart.update_rvecs">
<tt class="descname">update_rvecs</tt><big>(</big><em>rvecs</em><big>)</big><a class="headerlink" href="#yaff.pes.ff.ForcePart.update_rvecs" title="Permalink to this definition">¶</a></dt>
<dd><p>Let the <tt class="docutils literal"><span class="pre">ForcePart</span></tt> object know that the cell vectors have changed.</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>rvecs</dt>
<dd>The new cell vectors.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="yaff.pes.ff.ForceField">
<em class="property">class </em><tt class="descclassname">yaff.pes.ff.</tt><tt class="descname">ForceField</tt><big>(</big><em>system</em>, <em>parts</em>, <em>nlist=None</em><big>)</big><a class="headerlink" href="#yaff.pes.ff.ForceField" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#yaff.pes.ff.ForcePart" title="yaff.pes.ff.ForcePart"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.ff.ForcePart</span></tt></a></p>
<p>A complete force field model.</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>system</dt>
<dd>An instance of the <tt class="docutils literal"><span class="pre">System</span></tt> class.</dd>
<dt>parts</dt>
<dd>A list of instances of sublcasses of <tt class="docutils literal"><span class="pre">ForcePart</span></tt>. These are
the different types of contributions to the force field, e.g.
valence interactions, real-space electrostatics, and so on.</dd>
</dl>
<p><strong>Optional arguments:</strong></p>
<dl class="docutils">
<dt>nlist</dt>
<dd>A <tt class="docutils literal"><span class="pre">NeighborList</span></tt> instance. This is required if some items in the
parts list use this nlist object.</dd>
</dl>
<dl class="method">
<dt id="yaff.pes.ff.ForceField.add_part">
<tt class="descname">add_part</tt><big>(</big><em>part</em><big>)</big><a class="headerlink" href="#yaff.pes.ff.ForceField.add_part" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="yaff.pes.ff.ForceField.generate">
<em class="property">classmethod </em><tt class="descname">generate</tt><big>(</big><em>system</em>, <em>parameters</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#yaff.pes.ff.ForceField.generate" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a force field for the given system with the given parameters.</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>system</dt>
<dd>An instance of the System class</dd>
<dt>parameters</dt>
<dd>Three types are accepted: (i) the filename of the parameter
file, which is a text file that adheres to YAFF parameter
format, (ii) a list of such filenames, or (ii) an instance of
the Parameters class.</dd>
</dl>
<p>See the constructor of the <a class="reference internal" href="#yaff.pes.generator.FFArgs" title="yaff.pes.generator.FFArgs"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.generator.FFArgs</span></tt></a> class
for the available optional arguments.</p>
<p>This method takes care of setting up the FF object, and configuring
all the necessary FF parts. This is a lot easier than creating an FF
with the default constructor. Parameters for atom types that are not
present in the system, are simply ignored.</p>
</dd></dl>

<dl class="method">
<dt id="yaff.pes.ff.ForceField.update_pos">
<tt class="descname">update_pos</tt><big>(</big><em>pos</em><big>)</big><a class="headerlink" href="#yaff.pes.ff.ForceField.update_pos" title="Permalink to this definition">¶</a></dt>
<dd><p>See <a class="reference internal" href="#yaff.pes.ff.ForcePart.update_pos" title="yaff.pes.ff.ForcePart.update_pos"><tt class="xref py py-meth docutils literal"><span class="pre">yaff.pes.ff.ForcePart.update_pos()</span></tt></a></p>
</dd></dl>

<dl class="method">
<dt id="yaff.pes.ff.ForceField.update_rvecs">
<tt class="descname">update_rvecs</tt><big>(</big><em>rvecs</em><big>)</big><a class="headerlink" href="#yaff.pes.ff.ForceField.update_rvecs" title="Permalink to this definition">¶</a></dt>
<dd><p>See <a class="reference internal" href="#yaff.pes.ff.ForcePart.update_rvecs" title="yaff.pes.ff.ForcePart.update_rvecs"><tt class="xref py py-meth docutils literal"><span class="pre">yaff.pes.ff.ForcePart.update_rvecs()</span></tt></a></p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="yaff.pes.ff.ForcePartPair">
<em class="property">class </em><tt class="descclassname">yaff.pes.ff.</tt><tt class="descname">ForcePartPair</tt><big>(</big><em>system</em>, <em>nlist</em>, <em>scalings</em>, <em>pair_pot</em><big>)</big><a class="headerlink" href="#yaff.pes.ff.ForcePartPair" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#yaff.pes.ff.ForcePart" title="yaff.pes.ff.ForcePart"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.ff.ForcePart</span></tt></a></p>
<p>A pairwise (short-range) non-bonding interaction term.</p>
<p>This part can be used for the short-range electrostatics, Van der Waals
terms, etc. Currently, one has to use multiple <tt class="docutils literal"><span class="pre">ForcePartPair</span></tt>
objects in a <tt class="docutils literal"><span class="pre">ForceField</span></tt> in order to combine different types of pairwise
energy terms, e.g. to combine an electrostatic term with a Van der
Waals term. (This may be changed in future to improve the computational
efficiency.)</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>system</dt>
<dd>The system to which this pairwise interaction applies.</dd>
<dt>nlist</dt>
<dd>A <tt class="docutils literal"><span class="pre">NeighborList</span></tt> object. This has to be the same as the one
passed to the ForceField object that contains this part.</dd>
<dt>scalings</dt>
<dd>A <tt class="docutils literal"><span class="pre">Scalings</span></tt> object. This object contains all the information
about the energy scaling of pairwise contributions that are
involved in covalent interactions. See
<tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.scalings.Scalings</span></tt> for more details.</dd>
<dt>pair_pot</dt>
<dd>An instance of the <tt class="docutils literal"><span class="pre">PairPot</span></tt> built-in class from
<a class="reference internal" href="#module-yaff.pes.ext" title="yaff.pes.ext"><tt class="xref py py-mod docutils literal"><span class="pre">yaff.pes.ext</span></tt></a>.</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="yaff.pes.ff.ForcePartEwaldReciprocal">
<em class="property">class </em><tt class="descclassname">yaff.pes.ff.</tt><tt class="descname">ForcePartEwaldReciprocal</tt><big>(</big><em>system</em>, <em>alpha</em>, <em>gcut=0.35</em>, <em>dielectric=1.0</em><big>)</big><a class="headerlink" href="#yaff.pes.ff.ForcePartEwaldReciprocal" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#yaff.pes.ff.ForcePart" title="yaff.pes.ff.ForcePart"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.ff.ForcePart</span></tt></a></p>
<p>The long-range contribution to the electrostatic interaction in 3D
periodic systems.</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>system</dt>
<dd>The system to which this interaction applies.</dd>
<dt>alpha</dt>
<dd>The alpha parameter in the Ewald summation method.</dd>
</dl>
<p><strong>Optional arguments:</strong></p>
<dl class="docutils">
<dt>gcut</dt>
<dd>The cutoff in reciprocal space.</dd>
<dt>dielectric</dt>
<dd>The scalar relative permittivity of the system.</dd>
</dl>
<dl class="method">
<dt id="yaff.pes.ff.ForcePartEwaldReciprocal.update_gmax">
<tt class="descname">update_gmax</tt><big>(</big><big>)</big><a class="headerlink" href="#yaff.pes.ff.ForcePartEwaldReciprocal.update_gmax" title="Permalink to this definition">¶</a></dt>
<dd><p>This routine must be called after the attribute self.gmax is modified.</p>
</dd></dl>

<dl class="method">
<dt id="yaff.pes.ff.ForcePartEwaldReciprocal.update_rvecs">
<tt class="descname">update_rvecs</tt><big>(</big><em>rvecs</em><big>)</big><a class="headerlink" href="#yaff.pes.ff.ForcePartEwaldReciprocal.update_rvecs" title="Permalink to this definition">¶</a></dt>
<dd><p>See <a class="reference internal" href="#yaff.pes.ff.ForcePart.update_rvecs" title="yaff.pes.ff.ForcePart.update_rvecs"><tt class="xref py py-meth docutils literal"><span class="pre">yaff.pes.ff.ForcePart.update_rvecs()</span></tt></a></p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="yaff.pes.ff.ForcePartEwaldReciprocalDD">
<em class="property">class </em><tt class="descclassname">yaff.pes.ff.</tt><tt class="descname">ForcePartEwaldReciprocalDD</tt><big>(</big><em>system</em>, <em>alpha</em>, <em>gcut=0.35</em><big>)</big><a class="headerlink" href="#yaff.pes.ff.ForcePartEwaldReciprocalDD" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#yaff.pes.ff.ForcePart" title="yaff.pes.ff.ForcePart"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.ff.ForcePart</span></tt></a></p>
<p>The long-range contribution to the dipole-dipole
electrostatic interaction in 3D periodic systems.</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>system</dt>
<dd>The system to which this interaction applies.</dd>
<dt>alpha</dt>
<dd>The alpha parameter in the Ewald summation method.</dd>
<dt>gcut</dt>
<dd>The cutoff in reciprocal space.</dd>
</dl>
<dl class="method">
<dt id="yaff.pes.ff.ForcePartEwaldReciprocalDD.update_gmax">
<tt class="descname">update_gmax</tt><big>(</big><big>)</big><a class="headerlink" href="#yaff.pes.ff.ForcePartEwaldReciprocalDD.update_gmax" title="Permalink to this definition">¶</a></dt>
<dd><p>This routine must be called after the attribute self.gmax is modified.</p>
</dd></dl>

<dl class="method">
<dt id="yaff.pes.ff.ForcePartEwaldReciprocalDD.update_rvecs">
<tt class="descname">update_rvecs</tt><big>(</big><em>rvecs</em><big>)</big><a class="headerlink" href="#yaff.pes.ff.ForcePartEwaldReciprocalDD.update_rvecs" title="Permalink to this definition">¶</a></dt>
<dd><p>See <a class="reference internal" href="#yaff.pes.ff.ForcePart.update_rvecs" title="yaff.pes.ff.ForcePart.update_rvecs"><tt class="xref py py-meth docutils literal"><span class="pre">yaff.pes.ff.ForcePart.update_rvecs()</span></tt></a></p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="yaff.pes.ff.ForcePartEwaldCorrectionDD">
<em class="property">class </em><tt class="descclassname">yaff.pes.ff.</tt><tt class="descname">ForcePartEwaldCorrectionDD</tt><big>(</big><em>system</em>, <em>alpha</em>, <em>scalings</em><big>)</big><a class="headerlink" href="#yaff.pes.ff.ForcePartEwaldCorrectionDD" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#yaff.pes.ff.ForcePart" title="yaff.pes.ff.ForcePart"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.ff.ForcePart</span></tt></a></p>
<p>Correction for the double counting in the long-range term of the Ewald sum.</p>
<p>This correction is only needed if scaling rules apply to the short-range
electrostatics.</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>system</dt>
<dd>The system to which this interaction applies.</dd>
<dt>alpha</dt>
<dd>The alpha parameter in the Ewald summation method.</dd>
<dt>scalings</dt>
<dd>A <tt class="docutils literal"><span class="pre">Scalings</span></tt> object. This object contains all the information
about the energy scaling of pairwise contributions that are
involved in covalent interactions. See
<tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.scalings.Scalings</span></tt> for more details.</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="yaff.pes.ff.ForcePartEwaldCorrection">
<em class="property">class </em><tt class="descclassname">yaff.pes.ff.</tt><tt class="descname">ForcePartEwaldCorrection</tt><big>(</big><em>system</em>, <em>alpha</em>, <em>scalings</em>, <em>dielectric=1.0</em><big>)</big><a class="headerlink" href="#yaff.pes.ff.ForcePartEwaldCorrection" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#yaff.pes.ff.ForcePart" title="yaff.pes.ff.ForcePart"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.ff.ForcePart</span></tt></a></p>
<p>Correction for the double counting in the long-range term of the Ewald sum.</p>
<p>This correction is only needed if scaling rules apply to the short-range
electrostatics.</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>system</dt>
<dd>The system to which this interaction applies.</dd>
<dt>alpha</dt>
<dd>The alpha parameter in the Ewald summation method.</dd>
<dt>scalings</dt>
<dd>A <tt class="docutils literal"><span class="pre">Scalings</span></tt> object. This object contains all the information
about the energy scaling of pairwise contributions that are
involved in covalent interactions. See
<tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.scalings.Scalings</span></tt> for more details.</dd>
</dl>
<p><strong>Optional arguments:</strong></p>
<dl class="docutils">
<dt>dielectric</dt>
<dd>The scalar relative permittivity of the system.</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="yaff.pes.ff.ForcePartEwaldNeutralizing">
<em class="property">class </em><tt class="descclassname">yaff.pes.ff.</tt><tt class="descname">ForcePartEwaldNeutralizing</tt><big>(</big><em>system</em>, <em>alpha</em>, <em>dielectric=1.0</em><big>)</big><a class="headerlink" href="#yaff.pes.ff.ForcePartEwaldNeutralizing" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#yaff.pes.ff.ForcePart" title="yaff.pes.ff.ForcePart"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.ff.ForcePart</span></tt></a></p>
<p>Neutralizing background correction for 3D periodic systems that are
charged.</p>
<p>This term is only required of the system is not neutral.</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>system</dt>
<dd>The system to which this interaction applies.</dd>
<dt>alpha</dt>
<dd>The alpha parameter in the Ewald summation method.</dd>
</dl>
<p><strong>Optional arguments:</strong></p>
<dl class="docutils">
<dt>dielectric</dt>
<dd>The scalar relative permittivity of the system.</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="yaff.pes.ff.ForcePartValence">
<em class="property">class </em><tt class="descclassname">yaff.pes.ff.</tt><tt class="descname">ForcePartValence</tt><big>(</big><em>system</em><big>)</big><a class="headerlink" href="#yaff.pes.ff.ForcePartValence" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#yaff.pes.ff.ForcePart" title="yaff.pes.ff.ForcePart"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.ff.ForcePart</span></tt></a></p>
<p>The covalent part of a force-field model.</p>
<p>The covalent force field is implemented in a three-layer approach,
similar to the implementation of a neural network:</p>
<ol class="arabic simple">
<li>The first layer consists of a <a class="reference internal" href="#yaff.pes.dlist.DeltaList" title="yaff.pes.dlist.DeltaList"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.dlist.DeltaList</span></tt></a> object
that computes all the relative vectors needed for the internal
coordinates in the covalent energy terms. This list is automatically
built up as energy terms are added with the <tt class="docutils literal"><span class="pre">add_term</span></tt> method. This
list also takes care of transforming <cite>derivatives of the energy
towards relative vectors</cite> into <cite>derivatives of the energy towards
Cartesian coordinates and the virial tensor</cite>.</li>
<li>The second layer consist of a
<a class="reference internal" href="#yaff.pes.iclist.InternalCoordinateList" title="yaff.pes.iclist.InternalCoordinateList"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.iclist.InternalCoordinateList</span></tt></a> object that computes
the internal coordinates, based on the <tt class="docutils literal"><span class="pre">DeltaList</span></tt>. This list is
also automatically built up as energy terms are added. The same list
is also responsible for transforming <cite>derivatives of the energy
towards internal coordinates</cite> into <cite>derivatives of the energy towards
relative vectors</cite>.</li>
<li>The third layers consists of a <a class="reference internal" href="#yaff.pes.vlist.ValenceList" title="yaff.pes.vlist.ValenceList"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.vlist.ValenceList</span></tt></a>
object. This list computes the covalent energy terms, based on the
result in the <tt class="docutils literal"><span class="pre">InternalCoordinateList</span></tt>. This list also computes the
derivatives of the energy terms towards the internal coordinates.</li>
</ol>
<p>The computation of the covalent energy is the so-called <cite>forward code
path</cite>, which consists of running through steps 1, 2 and 3, in that order.
The derivatives of the energy are computed in the so-called <cite>backward
code path</cite>, which consists of taking steps 1, 2 and 3 in reverse order.
This basic idea of back-propagation for the computation of derivatives
comes from the field of neural networks. More details can be found in the
chapter, <a class="reference internal" href="dg_backprop.html#dg-sec-backprop"><em>The back-propagation algorithm for the computation of energy derivatives</em></a>.</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>system</dt>
<dd>An instance of the <tt class="docutils literal"><span class="pre">System</span></tt> class.</dd>
</dl>
<dl class="method">
<dt id="yaff.pes.ff.ForcePartValence.add_term">
<tt class="descname">add_term</tt><big>(</big><em>term</em><big>)</big><a class="headerlink" href="#yaff.pes.ff.ForcePartValence.add_term" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a new term to the covalent force field.</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>term</dt>
<dd>An instance of the class <tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.ff.vlist.ValenceTerm</span></tt>.</dd>
</dl>
<p>In principle, one should add all energy terms before calling the
<tt class="docutils literal"><span class="pre">compute</span></tt> method, but with the current implementation of Yaff,
energy terms can be added at any time. (This may change in future.)</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="yaff.pes.ff.ForcePartPressure">
<em class="property">class </em><tt class="descclassname">yaff.pes.ff.</tt><tt class="descname">ForcePartPressure</tt><big>(</big><em>system</em>, <em>pext</em><big>)</big><a class="headerlink" href="#yaff.pes.ff.ForcePartPressure" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#yaff.pes.ff.ForcePart" title="yaff.pes.ff.ForcePart"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.ff.ForcePart</span></tt></a></p>
<p>Applies a constant istropic pressure.</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>system</dt>
<dd>An instance of the <tt class="docutils literal"><span class="pre">System</span></tt> class.</dd>
<dt>pext</dt>
<dd>The external pressure. (Positive will shrink the system.) In
case of 2D-PBC, this is the surface tension. In case of 1D, this
is the linear strain.</dd>
</dl>
<p>This force part is only applicable to systems that are periodic.</p>
</dd></dl>

<dl class="class">
<dt id="yaff.pes.ff.ForcePartGrid">
<em class="property">class </em><tt class="descclassname">yaff.pes.ff.</tt><tt class="descname">ForcePartGrid</tt><big>(</big><em>system</em>, <em>grids</em><big>)</big><a class="headerlink" href="#yaff.pes.ff.ForcePartGrid" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#yaff.pes.ff.ForcePart" title="yaff.pes.ff.ForcePart"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.ff.ForcePart</span></tt></a></p>
<p>Energies obtained by grid interpolation.</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>system</dt>
<dd>An instance of the <tt class="docutils literal"><span class="pre">System</span></tt> class.</dd>
<dt>grids</dt>
<dd>A dictionary with (ffatype, grid) items. Each grid must be a
three-dimensional array with energies.</dd>
</dl>
<p>This force part is only applicable to systems that are 3D periodic.</p>
</dd></dl>

</div>
<div class="section" id="module-yaff.pes.generator">
<span id="yaff-pes-generator-automatically-generate-force-field-models"></span><h2>2.4. <tt class="docutils literal"><span class="pre">yaff.pes.generator</span></tt> &#8211; Automatically generate force field models<a class="headerlink" href="#module-yaff.pes.generator" title="Permalink to this headline">¶</a></h2>
<p>Automatically generate force field models</p>
<p>This module contains all the machinery needed to support the
<a class="reference internal" href="#yaff.pes.ff.ForceField.generate" title="yaff.pes.ff.ForceField.generate"><tt class="xref py py-meth docutils literal"><span class="pre">yaff.pes.ff.ForceField.generate()</span></tt></a> method.</p>
<dl class="class">
<dt id="yaff.pes.generator.FFArgs">
<em class="property">class </em><tt class="descclassname">yaff.pes.generator.</tt><tt class="descname">FFArgs</tt><big>(</big><em>rcut=18.89726133921252</em>, <em>tr=&lt;yaff.pes.ext.Switch3 object at 0x2d50c90&gt;</em>, <em>alpha_scale=3.5</em>, <em>gcut_scale=1.1</em>, <em>skin=0</em>, <em>smooth_ei=False</em>, <em>reci_ei='ewald'</em><big>)</big><a class="headerlink" href="#yaff.pes.generator.FFArgs" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Data structure that holds all arguments for the ForceField constructor</p>
<p>The attributes of this object are gradually filled up by the various
generators based on the data in the ParsedPars object.</p>
<p><strong>Optional arguments:</strong></p>
<p>Some optional arguments only make sense if related parameters in the
parameter file are present.</p>
<dl class="docutils">
<dt>rcut</dt>
<dd>The real space cutoff used by all pair potentials.</dd>
<dt>tr</dt>
<dd>Default truncation model for everything except the electrostatic
interactions. The electrostatic interactions are not truncated
by default.</dd>
<dt>alpha_scale</dt>
<dd>Determines the alpha parameter in the Ewald summation based on
the real-space cutoff: alpha = alpha_scale / rcut. Higher
values for this parameter imply a faster convergence of the
reciprocal terms, but a slower convergence in real-space.</dd>
<dt>gcut_scale</dt>
<dd>Determines the reciprocale space cutoff based on the alpha
parameter: gcut = gcut_scale * alpha. Higher values for this
parameter imply a better convergence in the reciprocal space.</dd>
<dt>skin</dt>
<dd>The skin parameter for the neighborlist.</dd>
<dt>smooth_ei</dt>
<dd>Flag for smooth truncations for the electrostatic interactions.</dd>
<dt>reci_ei</dt>
<dd>The method to be used for the reciprocal contribution to the
electrostatic interactions in the case of periodic systems. This
must be one of &#8216;ignore&#8217; or &#8216;ewald&#8217;. The &#8216;ewald&#8217; option is only
supported for 3D periodic systems.</dd>
</dl>
<p>The actual value of gcut, which depends on both gcut_scale and
alpha_scale, determines the computational cost of the reciprocal term
in the Ewald summation. The default values are just examples. An
optimal trade-off between accuracy and computational cost requires
some tuning. Dimensionless scaling parameters are used to make sure
that the numerical errors do not depend too much on the real space
cutoff and the system size.</p>
<dl class="method">
<dt id="yaff.pes.generator.FFArgs.get_nlist">
<tt class="descname">get_nlist</tt><big>(</big><em>system</em><big>)</big><a class="headerlink" href="#yaff.pes.generator.FFArgs.get_nlist" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="yaff.pes.generator.FFArgs.get_part">
<tt class="descname">get_part</tt><big>(</big><em>ForcePartClass</em><big>)</big><a class="headerlink" href="#yaff.pes.generator.FFArgs.get_part" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="yaff.pes.generator.FFArgs.get_part_pair">
<tt class="descname">get_part_pair</tt><big>(</big><em>PairPotClass</em><big>)</big><a class="headerlink" href="#yaff.pes.generator.FFArgs.get_part_pair" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="yaff.pes.generator.FFArgs.get_part_valence">
<tt class="descname">get_part_valence</tt><big>(</big><em>system</em><big>)</big><a class="headerlink" href="#yaff.pes.generator.FFArgs.get_part_valence" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="yaff.pes.generator.FFArgs.add_electrostatic_parts">
<tt class="descname">add_electrostatic_parts</tt><big>(</big><em>system</em>, <em>scalings</em>, <em>dielectric</em><big>)</big><a class="headerlink" href="#yaff.pes.generator.FFArgs.add_electrostatic_parts" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="yaff.pes.generator.Generator">
<em class="property">class </em><tt class="descclassname">yaff.pes.generator.</tt><tt class="descname">Generator</tt><a class="headerlink" href="#yaff.pes.generator.Generator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Creates (part of a) ForceField object automatically.</p>
<p>A generator is a class that describes how a part of a parameter file
must be turned into a part of ForceField object. As the generator
proceeds, it will modify and extend the current arguments of the FF. They
should be implemented such that the order of the generators is not
important.</p>
<p><strong>Important class attributes:</strong></p>
<dl class="docutils">
<dt>prefix</dt>
<dd>The prefix string that must match the prefix in the parameter file.
If this is None, it is assumed that the Generator class is abstract.
In that case it will be ignored by the apply_generators function
at the bottom of this module.</dd>
<dt>par_info</dt>
<dd>A description of the parameters on a single line (PARS suffix)</dd>
<dt>suffixes</dt>
<dd>The supported suffixes</dd>
<dt>allow_superpositions</dt>
<dd>Whether multiple PARS lines with the same atom types are allowed.
This is rarely the case, except for the TORSIONS and a few other
weirdos.</dd>
</dl>
<dl class="attribute">
<dt id="yaff.pes.generator.Generator.prefix">
<tt class="descname">prefix</tt><em class="property"> = None</em><a class="headerlink" href="#yaff.pes.generator.Generator.prefix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.Generator.par_info">
<tt class="descname">par_info</tt><em class="property"> = None</em><a class="headerlink" href="#yaff.pes.generator.Generator.par_info" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.Generator.suffixes">
<tt class="descname">suffixes</tt><em class="property"> = None</em><a class="headerlink" href="#yaff.pes.generator.Generator.suffixes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.Generator.allow_superposition">
<tt class="descname">allow_superposition</tt><em class="property"> = False</em><a class="headerlink" href="#yaff.pes.generator.Generator.allow_superposition" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="yaff.pes.generator.Generator.__call__">
<tt class="descname">__call__</tt><big>(</big><em>system</em>, <em>parsec</em>, <em>ff_args</em><big>)</big><a class="headerlink" href="#yaff.pes.generator.Generator.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Add contributions to the force field from this generator</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>system</dt>
<dd>The System object for which a force field is being prepared</dd>
<dt>parse</dt>
<dd>An instance of the ParameterSection class</dd>
<dt>ff_ars</dt>
<dd>An instance of the FFargs class</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="yaff.pes.generator.Generator.check_suffixes">
<tt class="descname">check_suffixes</tt><big>(</big><em>parsec</em><big>)</big><a class="headerlink" href="#yaff.pes.generator.Generator.check_suffixes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="yaff.pes.generator.Generator.process_units">
<tt class="descname">process_units</tt><big>(</big><em>pardef</em><big>)</big><a class="headerlink" href="#yaff.pes.generator.Generator.process_units" title="Permalink to this definition">¶</a></dt>
<dd><p>Load parameter conversion information</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>pardef</dt>
<dd>An instance of the ParameterDefinition class.</dd>
</dl>
<p>Returns a dictionary with (name, converion) pairs.</p>
</dd></dl>

<dl class="method">
<dt id="yaff.pes.generator.Generator.process_pars">
<tt class="descname">process_pars</tt><big>(</big><em>pardef</em>, <em>conversions</em>, <em>nffatype</em>, <em>par_info=None</em><big>)</big><a class="headerlink" href="#yaff.pes.generator.Generator.process_pars" title="Permalink to this definition">¶</a></dt>
<dd><p>Load parameter and apply conversion factors</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>pardef</dt>
<dd>An instance of the ParameterDefinition class.</dd>
<dt>conversions</dt>
<dd>A dictionary with (name, conversion) items.</dd>
<dt>nffatype</dt>
<dd>The number of ffatypes per line of parameters.</dd>
</dl>
<p><strong>Optional arguments:</strong></p>
<dl class="docutils">
<dt>par_info</dt>
<dd>A custom description of the parameters. If not present,
self.par_info is used. This is convenient when this method
is used to parse other definitions than PARS.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="yaff.pes.generator.Generator.iter_alt_keys">
<tt class="descname">iter_alt_keys</tt><big>(</big><em>key</em><big>)</big><a class="headerlink" href="#yaff.pes.generator.Generator.iter_alt_keys" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterates of all equivalent reorderings of a tuple of ffatypes</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="yaff.pes.generator.ValenceGenerator">
<em class="property">class </em><tt class="descclassname">yaff.pes.generator.</tt><tt class="descname">ValenceGenerator</tt><a class="headerlink" href="#yaff.pes.generator.ValenceGenerator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#yaff.pes.generator.Generator" title="yaff.pes.generator.Generator"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.generator.Generator</span></tt></a></p>
<p>All generators for diagonal valence terms derive from this class.</p>
<p><strong>More important attributes:</strong></p>
<dl class="docutils">
<dt>nffatype</dt>
<dd>The number of atoms involved in the internal coordinates. Hence
this is also the number ffatypes in a single row in the force field
parameter file.</dd>
<dt>ICClass</dt>
<dd>The <tt class="docutils literal"><span class="pre">InternalCoordinate</span></tt> class. See <tt class="docutils literal"><span class="pre">yaff.pes.iclist</span></tt>.</dd>
<dt>VClass</dt>
<dd>The <tt class="docutils literal"><span class="pre">ValenceTerm</span></tt> class. See <tt class="docutils literal"><span class="pre">yaff.pes.vlist</span></tt>.</dd>
</dl>
<dl class="attribute">
<dt id="yaff.pes.generator.ValenceGenerator.suffixes">
<tt class="descname">suffixes</tt><em class="property"> = ['UNIT', 'PARS']</em><a class="headerlink" href="#yaff.pes.generator.ValenceGenerator.suffixes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.ValenceGenerator.nffatype">
<tt class="descname">nffatype</tt><em class="property"> = None</em><a class="headerlink" href="#yaff.pes.generator.ValenceGenerator.nffatype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.ValenceGenerator.ICClass">
<tt class="descname">ICClass</tt><em class="property"> = None</em><a class="headerlink" href="#yaff.pes.generator.ValenceGenerator.ICClass" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.ValenceGenerator.VClass">
<tt class="descname">VClass</tt><em class="property"> = None</em><a class="headerlink" href="#yaff.pes.generator.ValenceGenerator.VClass" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="yaff.pes.generator.ValenceGenerator.__call__">
<tt class="descname">__call__</tt><big>(</big><em>system</em>, <em>parsec</em>, <em>ff_args</em><big>)</big><a class="headerlink" href="#yaff.pes.generator.ValenceGenerator.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Add contributions to the force field from a ValenceGenerator</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>system</dt>
<dd>The System object for which a force field is being prepared</dd>
<dt>parse</dt>
<dd>An instance of the ParameterSection class</dd>
<dt>ff_ars</dt>
<dd>An instance of the FFargs class</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="yaff.pes.generator.ValenceGenerator.apply">
<tt class="descname">apply</tt><big>(</big><em>par_table</em>, <em>system</em>, <em>ff_args</em><big>)</big><a class="headerlink" href="#yaff.pes.generator.ValenceGenerator.apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate terms for the system based on the par_table</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>par_table</dt>
<dd>A dictionary with tuples of ffatypes is keys and lists of
parameters as values.</dd>
<dt>system</dt>
<dd>The system for which the force field is generated.</dd>
<dt>ff_args</dt>
<dd>An instance of the FFArgs class.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="yaff.pes.generator.ValenceGenerator.get_vterm">
<tt class="descname">get_vterm</tt><big>(</big><em>pars</em>, <em>indexes</em><big>)</big><a class="headerlink" href="#yaff.pes.generator.ValenceGenerator.get_vterm" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an instane of the ValenceTerm class with the proper InternalCoordinate instance</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>pars</dt>
<dd>The parameters for the ValenceTerm class.</dd>
<dt>indexes</dt>
<dd>The atom indexes used to define the internal coordinate</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="yaff.pes.generator.ValenceGenerator.iter_indexes">
<tt class="descname">iter_indexes</tt><big>(</big><em>system</em><big>)</big><a class="headerlink" href="#yaff.pes.generator.ValenceGenerator.iter_indexes" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over all tuples of indexes for the internal coordinate</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="yaff.pes.generator.BondGenerator">
<em class="property">class </em><tt class="descclassname">yaff.pes.generator.</tt><tt class="descname">BondGenerator</tt><a class="headerlink" href="#yaff.pes.generator.BondGenerator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#yaff.pes.generator.ValenceGenerator" title="yaff.pes.generator.ValenceGenerator"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.generator.ValenceGenerator</span></tt></a></p>
<dl class="attribute">
<dt id="yaff.pes.generator.BondGenerator.par_info">
<tt class="descname">par_info</tt><em class="property"> = [('K', &lt;type 'float'&gt;), ('R0', &lt;type 'float'&gt;)]</em><a class="headerlink" href="#yaff.pes.generator.BondGenerator.par_info" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.BondGenerator.nffatype">
<tt class="descname">nffatype</tt><em class="property"> = 2</em><a class="headerlink" href="#yaff.pes.generator.BondGenerator.nffatype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.BondGenerator.ICClass">
<tt class="descname">ICClass</tt><a class="headerlink" href="#yaff.pes.generator.BondGenerator.ICClass" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <tt class="xref py py-class docutils literal"><span class="pre">Bond</span></tt></p>
</dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.BondGenerator.VClass">
<tt class="descname">VClass</tt><em class="property"> = None</em><a class="headerlink" href="#yaff.pes.generator.BondGenerator.VClass" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="yaff.pes.generator.BondGenerator.iter_alt_keys">
<tt class="descname">iter_alt_keys</tt><big>(</big><em>key</em><big>)</big><a class="headerlink" href="#yaff.pes.generator.BondGenerator.iter_alt_keys" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="yaff.pes.generator.BondGenerator.iter_indexes">
<tt class="descname">iter_indexes</tt><big>(</big><em>system</em><big>)</big><a class="headerlink" href="#yaff.pes.generator.BondGenerator.iter_indexes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="yaff.pes.generator.BondHarmGenerator">
<em class="property">class </em><tt class="descclassname">yaff.pes.generator.</tt><tt class="descname">BondHarmGenerator</tt><a class="headerlink" href="#yaff.pes.generator.BondHarmGenerator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#yaff.pes.generator.BondGenerator" title="yaff.pes.generator.BondGenerator"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.generator.BondGenerator</span></tt></a></p>
<dl class="attribute">
<dt id="yaff.pes.generator.BondHarmGenerator.prefix">
<tt class="descname">prefix</tt><em class="property"> = 'BONDHARM'</em><a class="headerlink" href="#yaff.pes.generator.BondHarmGenerator.prefix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.BondHarmGenerator.VClass">
<tt class="descname">VClass</tt><a class="headerlink" href="#yaff.pes.generator.BondHarmGenerator.VClass" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <tt class="xref py py-class docutils literal"><span class="pre">Harmonic</span></tt></p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="yaff.pes.generator.BondFuesGenerator">
<em class="property">class </em><tt class="descclassname">yaff.pes.generator.</tt><tt class="descname">BondFuesGenerator</tt><a class="headerlink" href="#yaff.pes.generator.BondFuesGenerator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#yaff.pes.generator.BondGenerator" title="yaff.pes.generator.BondGenerator"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.generator.BondGenerator</span></tt></a></p>
<dl class="attribute">
<dt id="yaff.pes.generator.BondFuesGenerator.prefix">
<tt class="descname">prefix</tt><em class="property"> = 'BONDFUES'</em><a class="headerlink" href="#yaff.pes.generator.BondFuesGenerator.prefix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.BondFuesGenerator.VClass">
<tt class="descname">VClass</tt><a class="headerlink" href="#yaff.pes.generator.BondFuesGenerator.VClass" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <tt class="xref py py-class docutils literal"><span class="pre">Fues</span></tt></p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="yaff.pes.generator.BendGenerator">
<em class="property">class </em><tt class="descclassname">yaff.pes.generator.</tt><tt class="descname">BendGenerator</tt><a class="headerlink" href="#yaff.pes.generator.BendGenerator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#yaff.pes.generator.ValenceGenerator" title="yaff.pes.generator.ValenceGenerator"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.generator.ValenceGenerator</span></tt></a></p>
<dl class="attribute">
<dt id="yaff.pes.generator.BendGenerator.nffatype">
<tt class="descname">nffatype</tt><em class="property"> = 3</em><a class="headerlink" href="#yaff.pes.generator.BendGenerator.nffatype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.BendGenerator.ICClass">
<tt class="descname">ICClass</tt><em class="property"> = None</em><a class="headerlink" href="#yaff.pes.generator.BendGenerator.ICClass" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.BendGenerator.VClass">
<tt class="descname">VClass</tt><a class="headerlink" href="#yaff.pes.generator.BendGenerator.VClass" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <tt class="xref py py-class docutils literal"><span class="pre">Harmonic</span></tt></p>
</dd></dl>

<dl class="method">
<dt id="yaff.pes.generator.BendGenerator.iter_alt_keys">
<tt class="descname">iter_alt_keys</tt><big>(</big><em>key</em><big>)</big><a class="headerlink" href="#yaff.pes.generator.BendGenerator.iter_alt_keys" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="yaff.pes.generator.BendGenerator.iter_indexes">
<tt class="descname">iter_indexes</tt><big>(</big><em>system</em><big>)</big><a class="headerlink" href="#yaff.pes.generator.BendGenerator.iter_indexes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="yaff.pes.generator.BendAngleHarmGenerator">
<em class="property">class </em><tt class="descclassname">yaff.pes.generator.</tt><tt class="descname">BendAngleHarmGenerator</tt><a class="headerlink" href="#yaff.pes.generator.BendAngleHarmGenerator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#yaff.pes.generator.BendGenerator" title="yaff.pes.generator.BendGenerator"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.generator.BendGenerator</span></tt></a></p>
<dl class="attribute">
<dt id="yaff.pes.generator.BendAngleHarmGenerator.par_info">
<tt class="descname">par_info</tt><em class="property"> = [('K', &lt;type 'float'&gt;), ('THETA0', &lt;type 'float'&gt;)]</em><a class="headerlink" href="#yaff.pes.generator.BendAngleHarmGenerator.par_info" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.BendAngleHarmGenerator.prefix">
<tt class="descname">prefix</tt><em class="property"> = 'BENDAHARM'</em><a class="headerlink" href="#yaff.pes.generator.BendAngleHarmGenerator.prefix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.BendAngleHarmGenerator.ICClass">
<tt class="descname">ICClass</tt><a class="headerlink" href="#yaff.pes.generator.BendAngleHarmGenerator.ICClass" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <tt class="xref py py-class docutils literal"><span class="pre">BendAngle</span></tt></p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="yaff.pes.generator.BendCosHarmGenerator">
<em class="property">class </em><tt class="descclassname">yaff.pes.generator.</tt><tt class="descname">BendCosHarmGenerator</tt><a class="headerlink" href="#yaff.pes.generator.BendCosHarmGenerator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#yaff.pes.generator.BendGenerator" title="yaff.pes.generator.BendGenerator"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.generator.BendGenerator</span></tt></a></p>
<dl class="attribute">
<dt id="yaff.pes.generator.BendCosHarmGenerator.par_info">
<tt class="descname">par_info</tt><em class="property"> = [('K', &lt;type 'float'&gt;), ('COS0', &lt;type 'float'&gt;)]</em><a class="headerlink" href="#yaff.pes.generator.BendCosHarmGenerator.par_info" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.BendCosHarmGenerator.prefix">
<tt class="descname">prefix</tt><em class="property"> = 'BENDCHARM'</em><a class="headerlink" href="#yaff.pes.generator.BendCosHarmGenerator.prefix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.BendCosHarmGenerator.ICClass">
<tt class="descname">ICClass</tt><a class="headerlink" href="#yaff.pes.generator.BendCosHarmGenerator.ICClass" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <tt class="xref py py-class docutils literal"><span class="pre">BendCos</span></tt></p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="yaff.pes.generator.UreyBradleyHarmGenerator">
<em class="property">class </em><tt class="descclassname">yaff.pes.generator.</tt><tt class="descname">UreyBradleyHarmGenerator</tt><a class="headerlink" href="#yaff.pes.generator.UreyBradleyHarmGenerator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#yaff.pes.generator.BendGenerator" title="yaff.pes.generator.BendGenerator"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.generator.BendGenerator</span></tt></a></p>
<dl class="attribute">
<dt id="yaff.pes.generator.UreyBradleyHarmGenerator.par_info">
<tt class="descname">par_info</tt><em class="property"> = [('K', &lt;type 'float'&gt;), ('R0', &lt;type 'float'&gt;)]</em><a class="headerlink" href="#yaff.pes.generator.UreyBradleyHarmGenerator.par_info" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.UreyBradleyHarmGenerator.prefix">
<tt class="descname">prefix</tt><em class="property"> = 'UBHARM'</em><a class="headerlink" href="#yaff.pes.generator.UreyBradleyHarmGenerator.prefix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.UreyBradleyHarmGenerator.ICClass">
<tt class="descname">ICClass</tt><a class="headerlink" href="#yaff.pes.generator.UreyBradleyHarmGenerator.ICClass" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <tt class="xref py py-class docutils literal"><span class="pre">UreyBradley</span></tt></p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="yaff.pes.generator.TorsionCosHarmGenerator">
<em class="property">class </em><tt class="descclassname">yaff.pes.generator.</tt><tt class="descname">TorsionCosHarmGenerator</tt><a class="headerlink" href="#yaff.pes.generator.TorsionCosHarmGenerator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#yaff.pes.generator.ValenceGenerator" title="yaff.pes.generator.ValenceGenerator"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.generator.ValenceGenerator</span></tt></a></p>
<dl class="attribute">
<dt id="yaff.pes.generator.TorsionCosHarmGenerator.nffatype">
<tt class="descname">nffatype</tt><em class="property"> = 4</em><a class="headerlink" href="#yaff.pes.generator.TorsionCosHarmGenerator.nffatype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.TorsionCosHarmGenerator.par_info">
<tt class="descname">par_info</tt><em class="property"> = [('A', &lt;type 'float'&gt;), ('COS0', &lt;type 'float'&gt;)]</em><a class="headerlink" href="#yaff.pes.generator.TorsionCosHarmGenerator.par_info" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.TorsionCosHarmGenerator.prefix">
<tt class="descname">prefix</tt><em class="property"> = 'TORSCHARM'</em><a class="headerlink" href="#yaff.pes.generator.TorsionCosHarmGenerator.prefix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.TorsionCosHarmGenerator.ICClass">
<tt class="descname">ICClass</tt><a class="headerlink" href="#yaff.pes.generator.TorsionCosHarmGenerator.ICClass" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <tt class="xref py py-class docutils literal"><span class="pre">DihedCos</span></tt></p>
</dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.TorsionCosHarmGenerator.VClass">
<tt class="descname">VClass</tt><a class="headerlink" href="#yaff.pes.generator.TorsionCosHarmGenerator.VClass" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <tt class="xref py py-class docutils literal"><span class="pre">Harmonic</span></tt></p>
</dd></dl>

<dl class="method">
<dt id="yaff.pes.generator.TorsionCosHarmGenerator.iter_alt_keys">
<tt class="descname">iter_alt_keys</tt><big>(</big><em>key</em><big>)</big><a class="headerlink" href="#yaff.pes.generator.TorsionCosHarmGenerator.iter_alt_keys" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="yaff.pes.generator.TorsionCosHarmGenerator.iter_indexes">
<tt class="descname">iter_indexes</tt><big>(</big><em>system</em><big>)</big><a class="headerlink" href="#yaff.pes.generator.TorsionCosHarmGenerator.iter_indexes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="yaff.pes.generator.TorsionGenerator">
<em class="property">class </em><tt class="descclassname">yaff.pes.generator.</tt><tt class="descname">TorsionGenerator</tt><a class="headerlink" href="#yaff.pes.generator.TorsionGenerator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#yaff.pes.generator.ValenceGenerator" title="yaff.pes.generator.ValenceGenerator"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.generator.ValenceGenerator</span></tt></a></p>
<dl class="attribute">
<dt id="yaff.pes.generator.TorsionGenerator.nffatype">
<tt class="descname">nffatype</tt><em class="property"> = 4</em><a class="headerlink" href="#yaff.pes.generator.TorsionGenerator.nffatype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.TorsionGenerator.par_info">
<tt class="descname">par_info</tt><em class="property"> = [('M', &lt;type 'int'&gt;), ('A', &lt;type 'float'&gt;), ('PHI0', &lt;type 'float'&gt;)]</em><a class="headerlink" href="#yaff.pes.generator.TorsionGenerator.par_info" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.TorsionGenerator.prefix">
<tt class="descname">prefix</tt><em class="property"> = 'TORSION'</em><a class="headerlink" href="#yaff.pes.generator.TorsionGenerator.prefix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.TorsionGenerator.ICClass">
<tt class="descname">ICClass</tt><a class="headerlink" href="#yaff.pes.generator.TorsionGenerator.ICClass" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <tt class="xref py py-class docutils literal"><span class="pre">DihedAngle</span></tt></p>
</dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.TorsionGenerator.VClass">
<tt class="descname">VClass</tt><a class="headerlink" href="#yaff.pes.generator.TorsionGenerator.VClass" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <tt class="xref py py-class docutils literal"><span class="pre">Cosine</span></tt></p>
</dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.TorsionGenerator.allow_superposition">
<tt class="descname">allow_superposition</tt><em class="property"> = True</em><a class="headerlink" href="#yaff.pes.generator.TorsionGenerator.allow_superposition" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="yaff.pes.generator.TorsionGenerator.iter_alt_keys">
<tt class="descname">iter_alt_keys</tt><big>(</big><em>key</em><big>)</big><a class="headerlink" href="#yaff.pes.generator.TorsionGenerator.iter_alt_keys" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="yaff.pes.generator.TorsionGenerator.iter_indexes">
<tt class="descname">iter_indexes</tt><big>(</big><em>system</em><big>)</big><a class="headerlink" href="#yaff.pes.generator.TorsionGenerator.iter_indexes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="yaff.pes.generator.TorsionGenerator.get_vterm">
<tt class="descname">get_vterm</tt><big>(</big><em>pars</em>, <em>indexes</em><big>)</big><a class="headerlink" href="#yaff.pes.generator.TorsionGenerator.get_vterm" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="yaff.pes.generator.OopAngleGenerator">
<em class="property">class </em><tt class="descclassname">yaff.pes.generator.</tt><tt class="descname">OopAngleGenerator</tt><a class="headerlink" href="#yaff.pes.generator.OopAngleGenerator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#yaff.pes.generator.ValenceGenerator" title="yaff.pes.generator.ValenceGenerator"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.generator.ValenceGenerator</span></tt></a></p>
<dl class="attribute">
<dt id="yaff.pes.generator.OopAngleGenerator.nffatype">
<tt class="descname">nffatype</tt><em class="property"> = 4</em><a class="headerlink" href="#yaff.pes.generator.OopAngleGenerator.nffatype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.OopAngleGenerator.par_info">
<tt class="descname">par_info</tt><em class="property"> = [('K', &lt;type 'float'&gt;), ('PSI0', &lt;type 'float'&gt;)]</em><a class="headerlink" href="#yaff.pes.generator.OopAngleGenerator.par_info" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.OopAngleGenerator.prefix">
<tt class="descname">prefix</tt><em class="property"> = 'OOPAngle'</em><a class="headerlink" href="#yaff.pes.generator.OopAngleGenerator.prefix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.OopAngleGenerator.ICClass">
<tt class="descname">ICClass</tt><a class="headerlink" href="#yaff.pes.generator.OopAngleGenerator.ICClass" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <tt class="xref py py-class docutils literal"><span class="pre">OopAngle</span></tt></p>
</dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.OopAngleGenerator.VClass">
<tt class="descname">VClass</tt><a class="headerlink" href="#yaff.pes.generator.OopAngleGenerator.VClass" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <tt class="xref py py-class docutils literal"><span class="pre">Harmonic</span></tt></p>
</dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.OopAngleGenerator.allow_superposition">
<tt class="descname">allow_superposition</tt><em class="property"> = True</em><a class="headerlink" href="#yaff.pes.generator.OopAngleGenerator.allow_superposition" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="yaff.pes.generator.OopAngleGenerator.iter_alt_keys">
<tt class="descname">iter_alt_keys</tt><big>(</big><em>key</em><big>)</big><a class="headerlink" href="#yaff.pes.generator.OopAngleGenerator.iter_alt_keys" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="yaff.pes.generator.OopAngleGenerator.iter_indexes">
<tt class="descname">iter_indexes</tt><big>(</big><em>system</em><big>)</big><a class="headerlink" href="#yaff.pes.generator.OopAngleGenerator.iter_indexes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="yaff.pes.generator.OopMeanAngleGenerator">
<em class="property">class </em><tt class="descclassname">yaff.pes.generator.</tt><tt class="descname">OopMeanAngleGenerator</tt><a class="headerlink" href="#yaff.pes.generator.OopMeanAngleGenerator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#yaff.pes.generator.ValenceGenerator" title="yaff.pes.generator.ValenceGenerator"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.generator.ValenceGenerator</span></tt></a></p>
<dl class="attribute">
<dt id="yaff.pes.generator.OopMeanAngleGenerator.nffatype">
<tt class="descname">nffatype</tt><em class="property"> = 4</em><a class="headerlink" href="#yaff.pes.generator.OopMeanAngleGenerator.nffatype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.OopMeanAngleGenerator.par_info">
<tt class="descname">par_info</tt><em class="property"> = [('K', &lt;type 'float'&gt;), ('PSI0', &lt;type 'float'&gt;)]</em><a class="headerlink" href="#yaff.pes.generator.OopMeanAngleGenerator.par_info" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.OopMeanAngleGenerator.prefix">
<tt class="descname">prefix</tt><em class="property"> = 'OOPMANGLE'</em><a class="headerlink" href="#yaff.pes.generator.OopMeanAngleGenerator.prefix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.OopMeanAngleGenerator.ICClass">
<tt class="descname">ICClass</tt><a class="headerlink" href="#yaff.pes.generator.OopMeanAngleGenerator.ICClass" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <tt class="xref py py-class docutils literal"><span class="pre">OopMeanAngle</span></tt></p>
</dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.OopMeanAngleGenerator.VClass">
<tt class="descname">VClass</tt><a class="headerlink" href="#yaff.pes.generator.OopMeanAngleGenerator.VClass" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <tt class="xref py py-class docutils literal"><span class="pre">Harmonic</span></tt></p>
</dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.OopMeanAngleGenerator.allow_superposition">
<tt class="descname">allow_superposition</tt><em class="property"> = True</em><a class="headerlink" href="#yaff.pes.generator.OopMeanAngleGenerator.allow_superposition" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="yaff.pes.generator.OopMeanAngleGenerator.iter_alt_keys">
<tt class="descname">iter_alt_keys</tt><big>(</big><em>key</em><big>)</big><a class="headerlink" href="#yaff.pes.generator.OopMeanAngleGenerator.iter_alt_keys" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="yaff.pes.generator.OopMeanAngleGenerator.iter_indexes">
<tt class="descname">iter_indexes</tt><big>(</big><em>system</em><big>)</big><a class="headerlink" href="#yaff.pes.generator.OopMeanAngleGenerator.iter_indexes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="yaff.pes.generator.OopCosGenerator">
<em class="property">class </em><tt class="descclassname">yaff.pes.generator.</tt><tt class="descname">OopCosGenerator</tt><a class="headerlink" href="#yaff.pes.generator.OopCosGenerator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#yaff.pes.generator.ValenceGenerator" title="yaff.pes.generator.ValenceGenerator"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.generator.ValenceGenerator</span></tt></a></p>
<dl class="attribute">
<dt id="yaff.pes.generator.OopCosGenerator.nffatype">
<tt class="descname">nffatype</tt><em class="property"> = 4</em><a class="headerlink" href="#yaff.pes.generator.OopCosGenerator.nffatype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.OopCosGenerator.par_info">
<tt class="descname">par_info</tt><em class="property"> = [('A', &lt;type 'float'&gt;)]</em><a class="headerlink" href="#yaff.pes.generator.OopCosGenerator.par_info" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.OopCosGenerator.prefix">
<tt class="descname">prefix</tt><em class="property"> = 'OOPCOS'</em><a class="headerlink" href="#yaff.pes.generator.OopCosGenerator.prefix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.OopCosGenerator.ICClass">
<tt class="descname">ICClass</tt><a class="headerlink" href="#yaff.pes.generator.OopCosGenerator.ICClass" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <tt class="xref py py-class docutils literal"><span class="pre">OopCos</span></tt></p>
</dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.OopCosGenerator.VClass">
<tt class="descname">VClass</tt><a class="headerlink" href="#yaff.pes.generator.OopCosGenerator.VClass" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <tt class="xref py py-class docutils literal"><span class="pre">Chebychev1</span></tt></p>
</dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.OopCosGenerator.allow_superposition">
<tt class="descname">allow_superposition</tt><em class="property"> = True</em><a class="headerlink" href="#yaff.pes.generator.OopCosGenerator.allow_superposition" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="yaff.pes.generator.OopCosGenerator.iter_alt_keys">
<tt class="descname">iter_alt_keys</tt><big>(</big><em>key</em><big>)</big><a class="headerlink" href="#yaff.pes.generator.OopCosGenerator.iter_alt_keys" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="yaff.pes.generator.OopCosGenerator.iter_indexes">
<tt class="descname">iter_indexes</tt><big>(</big><em>system</em><big>)</big><a class="headerlink" href="#yaff.pes.generator.OopCosGenerator.iter_indexes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="yaff.pes.generator.OopCosGenerator.get_vterm">
<tt class="descname">get_vterm</tt><big>(</big><em>pars</em>, <em>indexes</em><big>)</big><a class="headerlink" href="#yaff.pes.generator.OopCosGenerator.get_vterm" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="yaff.pes.generator.OopMeanCosGenerator">
<em class="property">class </em><tt class="descclassname">yaff.pes.generator.</tt><tt class="descname">OopMeanCosGenerator</tt><a class="headerlink" href="#yaff.pes.generator.OopMeanCosGenerator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#yaff.pes.generator.ValenceGenerator" title="yaff.pes.generator.ValenceGenerator"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.generator.ValenceGenerator</span></tt></a></p>
<dl class="attribute">
<dt id="yaff.pes.generator.OopMeanCosGenerator.nffatype">
<tt class="descname">nffatype</tt><em class="property"> = 4</em><a class="headerlink" href="#yaff.pes.generator.OopMeanCosGenerator.nffatype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.OopMeanCosGenerator.par_info">
<tt class="descname">par_info</tt><em class="property"> = [('A', &lt;type 'float'&gt;)]</em><a class="headerlink" href="#yaff.pes.generator.OopMeanCosGenerator.par_info" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.OopMeanCosGenerator.prefix">
<tt class="descname">prefix</tt><em class="property"> = 'OOPMCOS'</em><a class="headerlink" href="#yaff.pes.generator.OopMeanCosGenerator.prefix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.OopMeanCosGenerator.ICClass">
<tt class="descname">ICClass</tt><a class="headerlink" href="#yaff.pes.generator.OopMeanCosGenerator.ICClass" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <tt class="xref py py-class docutils literal"><span class="pre">OopMeanCos</span></tt></p>
</dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.OopMeanCosGenerator.VClass">
<tt class="descname">VClass</tt><a class="headerlink" href="#yaff.pes.generator.OopMeanCosGenerator.VClass" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <tt class="xref py py-class docutils literal"><span class="pre">Chebychev1</span></tt></p>
</dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.OopMeanCosGenerator.allow_superposition">
<tt class="descname">allow_superposition</tt><em class="property"> = True</em><a class="headerlink" href="#yaff.pes.generator.OopMeanCosGenerator.allow_superposition" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="yaff.pes.generator.OopMeanCosGenerator.iter_alt_keys">
<tt class="descname">iter_alt_keys</tt><big>(</big><em>key</em><big>)</big><a class="headerlink" href="#yaff.pes.generator.OopMeanCosGenerator.iter_alt_keys" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="yaff.pes.generator.OopMeanCosGenerator.iter_indexes">
<tt class="descname">iter_indexes</tt><big>(</big><em>system</em><big>)</big><a class="headerlink" href="#yaff.pes.generator.OopMeanCosGenerator.iter_indexes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="yaff.pes.generator.OopMeanCosGenerator.get_vterm">
<tt class="descname">get_vterm</tt><big>(</big><em>pars</em>, <em>indexes</em><big>)</big><a class="headerlink" href="#yaff.pes.generator.OopMeanCosGenerator.get_vterm" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="yaff.pes.generator.OopDistGenerator">
<em class="property">class </em><tt class="descclassname">yaff.pes.generator.</tt><tt class="descname">OopDistGenerator</tt><a class="headerlink" href="#yaff.pes.generator.OopDistGenerator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#yaff.pes.generator.ValenceGenerator" title="yaff.pes.generator.ValenceGenerator"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.generator.ValenceGenerator</span></tt></a></p>
<dl class="attribute">
<dt id="yaff.pes.generator.OopDistGenerator.nffatype">
<tt class="descname">nffatype</tt><em class="property"> = 4</em><a class="headerlink" href="#yaff.pes.generator.OopDistGenerator.nffatype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.OopDistGenerator.par_info">
<tt class="descname">par_info</tt><em class="property"> = [('K', &lt;type 'float'&gt;), ('D0', &lt;type 'float'&gt;)]</em><a class="headerlink" href="#yaff.pes.generator.OopDistGenerator.par_info" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.OopDistGenerator.prefix">
<tt class="descname">prefix</tt><em class="property"> = 'OOPDIST'</em><a class="headerlink" href="#yaff.pes.generator.OopDistGenerator.prefix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.OopDistGenerator.ICClass">
<tt class="descname">ICClass</tt><a class="headerlink" href="#yaff.pes.generator.OopDistGenerator.ICClass" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <tt class="xref py py-class docutils literal"><span class="pre">OopDist</span></tt></p>
</dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.OopDistGenerator.VClass">
<tt class="descname">VClass</tt><a class="headerlink" href="#yaff.pes.generator.OopDistGenerator.VClass" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <tt class="xref py py-class docutils literal"><span class="pre">Harmonic</span></tt></p>
</dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.OopDistGenerator.allow_superposition">
<tt class="descname">allow_superposition</tt><em class="property"> = False</em><a class="headerlink" href="#yaff.pes.generator.OopDistGenerator.allow_superposition" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="yaff.pes.generator.OopDistGenerator.iter_alt_keys">
<tt class="descname">iter_alt_keys</tt><big>(</big><em>key</em><big>)</big><a class="headerlink" href="#yaff.pes.generator.OopDistGenerator.iter_alt_keys" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="yaff.pes.generator.OopDistGenerator.iter_indexes">
<tt class="descname">iter_indexes</tt><big>(</big><em>system</em><big>)</big><a class="headerlink" href="#yaff.pes.generator.OopDistGenerator.iter_indexes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="yaff.pes.generator.ValenceCrossGenerator">
<em class="property">class </em><tt class="descclassname">yaff.pes.generator.</tt><tt class="descname">ValenceCrossGenerator</tt><a class="headerlink" href="#yaff.pes.generator.ValenceCrossGenerator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#yaff.pes.generator.Generator" title="yaff.pes.generator.Generator"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.generator.Generator</span></tt></a></p>
<p>All generators for cross valence terms derive from this class.</p>
<p><strong>More important attributes:</strong></p>
<dl class="docutils">
<dt>nffatype</dt>
<dd>The number of atoms involved in the internal coordinates. Hence
this is also the number ffatypes in a single row in the force field
parameter file.</dd>
<dt>ICClass0</dt>
<dd>The first <tt class="docutils literal"><span class="pre">InternalCoordinate</span></tt> class. See <tt class="docutils literal"><span class="pre">yaff.pes.iclist</span></tt>.</dd>
<dt>ICClass1</dt>
<dd>The second <tt class="docutils literal"><span class="pre">InternalCoordinate</span></tt> class. See <tt class="docutils literal"><span class="pre">yaff.pes.iclist</span></tt>.</dd>
<dt>ICClass2</dt>
<dd>The third <tt class="docutils literal"><span class="pre">InternalCoordinate</span></tt> class. See <tt class="docutils literal"><span class="pre">yaff.pes.iclist</span></tt>.</dd>
<dt>VClass01</dt>
<dd>The <tt class="docutils literal"><span class="pre">ValenceTerm</span></tt> class for the cross term between IC0 and IC1.
See <tt class="docutils literal"><span class="pre">yaff.pes.vlist</span></tt>.</dd>
<dt>VClass02</dt>
<dd>The <tt class="docutils literal"><span class="pre">ValenceTerm</span></tt> class for the cross term between IC0 and IC2.
See <tt class="docutils literal"><span class="pre">yaff.pes.vlist</span></tt>.</dd>
<dt>VClass12</dt>
<dd>The <tt class="docutils literal"><span class="pre">ValenceTerm</span></tt> class for the cross term between IC1 and IC2.
See <tt class="docutils literal"><span class="pre">yaff.pes.vlist</span></tt>.</dd>
</dl>
<dl class="attribute">
<dt id="yaff.pes.generator.ValenceCrossGenerator.suffixes">
<tt class="descname">suffixes</tt><em class="property"> = ['UNIT', 'PARS']</em><a class="headerlink" href="#yaff.pes.generator.ValenceCrossGenerator.suffixes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.ValenceCrossGenerator.nffatype">
<tt class="descname">nffatype</tt><em class="property"> = None</em><a class="headerlink" href="#yaff.pes.generator.ValenceCrossGenerator.nffatype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.ValenceCrossGenerator.ICClass0">
<tt class="descname">ICClass0</tt><em class="property"> = None</em><a class="headerlink" href="#yaff.pes.generator.ValenceCrossGenerator.ICClass0" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.ValenceCrossGenerator.ICClass1">
<tt class="descname">ICClass1</tt><em class="property"> = None</em><a class="headerlink" href="#yaff.pes.generator.ValenceCrossGenerator.ICClass1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.ValenceCrossGenerator.ICClass2">
<tt class="descname">ICClass2</tt><em class="property"> = None</em><a class="headerlink" href="#yaff.pes.generator.ValenceCrossGenerator.ICClass2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.ValenceCrossGenerator.VClass01">
<tt class="descname">VClass01</tt><em class="property"> = None</em><a class="headerlink" href="#yaff.pes.generator.ValenceCrossGenerator.VClass01" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.ValenceCrossGenerator.VClass02">
<tt class="descname">VClass02</tt><em class="property"> = None</em><a class="headerlink" href="#yaff.pes.generator.ValenceCrossGenerator.VClass02" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.ValenceCrossGenerator.VClass12">
<tt class="descname">VClass12</tt><em class="property"> = None</em><a class="headerlink" href="#yaff.pes.generator.ValenceCrossGenerator.VClass12" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="yaff.pes.generator.ValenceCrossGenerator.__call__">
<tt class="descname">__call__</tt><big>(</big><em>system</em>, <em>parsec</em>, <em>ff_args</em><big>)</big><a class="headerlink" href="#yaff.pes.generator.ValenceCrossGenerator.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Add contributions to the force field from a ValenceCrossGenerator</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>system</dt>
<dd>The System object for which a force field is being prepared</dd>
<dt>parse</dt>
<dd>An instance of the ParameterSection class</dd>
<dt>ff_ars</dt>
<dd>An instance of the FFargs class</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="yaff.pes.generator.ValenceCrossGenerator.apply">
<tt class="descname">apply</tt><big>(</big><em>par_table</em>, <em>system</em>, <em>ff_args</em><big>)</big><a class="headerlink" href="#yaff.pes.generator.ValenceCrossGenerator.apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate terms for the system based on the par_table</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>par_table</dt>
<dd>A dictionary with tuples of ffatypes is keys and lists of
parameters as values.</dd>
<dt>system</dt>
<dd>The system for which the force field is generated.</dd>
<dt>ff_args</dt>
<dd>An instance of the FFArgs class.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="yaff.pes.generator.ValenceCrossGenerator.iter_indexes">
<tt class="descname">iter_indexes</tt><big>(</big><em>system</em><big>)</big><a class="headerlink" href="#yaff.pes.generator.ValenceCrossGenerator.iter_indexes" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over all tuples of indexes for the pair of internal coordinates</p>
</dd></dl>

<dl class="method">
<dt id="yaff.pes.generator.ValenceCrossGenerator.get_indexes0">
<tt class="descname">get_indexes0</tt><big>(</big><em>indexes</em><big>)</big><a class="headerlink" href="#yaff.pes.generator.ValenceCrossGenerator.get_indexes0" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the indexes for the first internal coordinate from the whole</p>
</dd></dl>

<dl class="method">
<dt id="yaff.pes.generator.ValenceCrossGenerator.get_indexes1">
<tt class="descname">get_indexes1</tt><big>(</big><em>indexes</em><big>)</big><a class="headerlink" href="#yaff.pes.generator.ValenceCrossGenerator.get_indexes1" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the indexes for the second internal coordinate from the whole</p>
</dd></dl>

<dl class="method">
<dt id="yaff.pes.generator.ValenceCrossGenerator.get_indexes2">
<tt class="descname">get_indexes2</tt><big>(</big><em>indexes</em><big>)</big><a class="headerlink" href="#yaff.pes.generator.ValenceCrossGenerator.get_indexes2" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the indexes for the third internal coordinate from the whole</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="yaff.pes.generator.CrossGenerator">
<em class="property">class </em><tt class="descclassname">yaff.pes.generator.</tt><tt class="descname">CrossGenerator</tt><a class="headerlink" href="#yaff.pes.generator.CrossGenerator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#yaff.pes.generator.ValenceCrossGenerator" title="yaff.pes.generator.ValenceCrossGenerator"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.generator.ValenceCrossGenerator</span></tt></a></p>
<dl class="attribute">
<dt id="yaff.pes.generator.CrossGenerator.prefix">
<tt class="descname">prefix</tt><em class="property"> = 'CROSS'</em><a class="headerlink" href="#yaff.pes.generator.CrossGenerator.prefix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.CrossGenerator.par_info">
<tt class="descname">par_info</tt><em class="property"> = [('KSS', &lt;type 'float'&gt;), ('KBS0', &lt;type 'float'&gt;), ('KBS1', &lt;type 'float'&gt;), ('R0', &lt;type 'float'&gt;), ('R1', &lt;type 'float'&gt;), ('THETA0', &lt;type 'float'&gt;)]</em><a class="headerlink" href="#yaff.pes.generator.CrossGenerator.par_info" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.CrossGenerator.nffatype">
<tt class="descname">nffatype</tt><em class="property"> = 3</em><a class="headerlink" href="#yaff.pes.generator.CrossGenerator.nffatype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.CrossGenerator.ICClass0">
<tt class="descname">ICClass0</tt><a class="headerlink" href="#yaff.pes.generator.CrossGenerator.ICClass0" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <tt class="xref py py-class docutils literal"><span class="pre">Bond</span></tt></p>
</dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.CrossGenerator.ICClass1">
<tt class="descname">ICClass1</tt><a class="headerlink" href="#yaff.pes.generator.CrossGenerator.ICClass1" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <tt class="xref py py-class docutils literal"><span class="pre">Bond</span></tt></p>
</dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.CrossGenerator.ICClass2">
<tt class="descname">ICClass2</tt><a class="headerlink" href="#yaff.pes.generator.CrossGenerator.ICClass2" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <tt class="xref py py-class docutils literal"><span class="pre">BendAngle</span></tt></p>
</dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.CrossGenerator.VClass01">
<tt class="descname">VClass01</tt><a class="headerlink" href="#yaff.pes.generator.CrossGenerator.VClass01" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <tt class="xref py py-class docutils literal"><span class="pre">Cross</span></tt></p>
</dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.CrossGenerator.VClass02">
<tt class="descname">VClass02</tt><a class="headerlink" href="#yaff.pes.generator.CrossGenerator.VClass02" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <tt class="xref py py-class docutils literal"><span class="pre">Cross</span></tt></p>
</dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.CrossGenerator.VClass12">
<tt class="descname">VClass12</tt><a class="headerlink" href="#yaff.pes.generator.CrossGenerator.VClass12" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <tt class="xref py py-class docutils literal"><span class="pre">Cross</span></tt></p>
</dd></dl>

<dl class="method">
<dt id="yaff.pes.generator.CrossGenerator.iter_alt_keys">
<tt class="descname">iter_alt_keys</tt><big>(</big><em>key</em><big>)</big><a class="headerlink" href="#yaff.pes.generator.CrossGenerator.iter_alt_keys" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="yaff.pes.generator.CrossGenerator.iter_indexes">
<tt class="descname">iter_indexes</tt><big>(</big><em>system</em><big>)</big><a class="headerlink" href="#yaff.pes.generator.CrossGenerator.iter_indexes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="yaff.pes.generator.CrossGenerator.get_indexes0">
<tt class="descname">get_indexes0</tt><big>(</big><em>indexes</em><big>)</big><a class="headerlink" href="#yaff.pes.generator.CrossGenerator.get_indexes0" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="yaff.pes.generator.CrossGenerator.get_indexes1">
<tt class="descname">get_indexes1</tt><big>(</big><em>indexes</em><big>)</big><a class="headerlink" href="#yaff.pes.generator.CrossGenerator.get_indexes1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="yaff.pes.generator.CrossGenerator.get_indexes2">
<tt class="descname">get_indexes2</tt><big>(</big><em>indexes</em><big>)</big><a class="headerlink" href="#yaff.pes.generator.CrossGenerator.get_indexes2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="yaff.pes.generator.NonbondedGenerator">
<em class="property">class </em><tt class="descclassname">yaff.pes.generator.</tt><tt class="descname">NonbondedGenerator</tt><a class="headerlink" href="#yaff.pes.generator.NonbondedGenerator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#yaff.pes.generator.Generator" title="yaff.pes.generator.Generator"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.generator.Generator</span></tt></a></p>
<p>All generators for the non-bonding interactions derive from this class</p>
<p><strong>One more important class attribute:</strong></p>
<dl class="docutils">
<dt>mixing_rules</dt>
<dd>A dictionary with (par_name, rule_name): (narg, rule_id) items</dd>
</dl>
<dl class="attribute">
<dt id="yaff.pes.generator.NonbondedGenerator.mixing_rules">
<tt class="descname">mixing_rules</tt><em class="property"> = None</em><a class="headerlink" href="#yaff.pes.generator.NonbondedGenerator.mixing_rules" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="yaff.pes.generator.NonbondedGenerator.process_scales">
<tt class="descname">process_scales</tt><big>(</big><em>pardef</em><big>)</big><a class="headerlink" href="#yaff.pes.generator.NonbondedGenerator.process_scales" title="Permalink to this definition">¶</a></dt>
<dd><p>Process the SCALE definitions</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>pardef</dt>
<dd>An instance of the ParameterDefinition class.</dd>
</dl>
<p>Returns a dictionary with (numbonds, scale) items.</p>
</dd></dl>

<dl class="method">
<dt id="yaff.pes.generator.NonbondedGenerator.process_mix">
<tt class="descname">process_mix</tt><big>(</big><em>pardef</em><big>)</big><a class="headerlink" href="#yaff.pes.generator.NonbondedGenerator.process_mix" title="Permalink to this definition">¶</a></dt>
<dd><p>Process mixing rules</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>pardef</dt>
<dd>An instance of the ParameterDefinition class.</dd>
</dl>
<p>Returns a dictionary of (par_name, (rule_id, rule_args)) items.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="yaff.pes.generator.LJGenerator">
<em class="property">class </em><tt class="descclassname">yaff.pes.generator.</tt><tt class="descname">LJGenerator</tt><a class="headerlink" href="#yaff.pes.generator.LJGenerator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#yaff.pes.generator.NonbondedGenerator" title="yaff.pes.generator.NonbondedGenerator"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.generator.NonbondedGenerator</span></tt></a></p>
<dl class="attribute">
<dt id="yaff.pes.generator.LJGenerator.prefix">
<tt class="descname">prefix</tt><em class="property"> = 'LJ'</em><a class="headerlink" href="#yaff.pes.generator.LJGenerator.prefix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.LJGenerator.suffixes">
<tt class="descname">suffixes</tt><em class="property"> = ['UNIT', 'SCALE', 'PARS']</em><a class="headerlink" href="#yaff.pes.generator.LJGenerator.suffixes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.LJGenerator.par_info">
<tt class="descname">par_info</tt><em class="property"> = [('SIGMA', &lt;type 'float'&gt;), ('EPSILON', &lt;type 'float'&gt;)]</em><a class="headerlink" href="#yaff.pes.generator.LJGenerator.par_info" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="yaff.pes.generator.LJGenerator.__call__">
<tt class="descname">__call__</tt><big>(</big><em>system</em>, <em>parsec</em>, <em>ff_args</em><big>)</big><a class="headerlink" href="#yaff.pes.generator.LJGenerator.__call__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="yaff.pes.generator.LJGenerator.apply">
<tt class="descname">apply</tt><big>(</big><em>par_table</em>, <em>scale_table</em>, <em>system</em>, <em>ff_args</em><big>)</big><a class="headerlink" href="#yaff.pes.generator.LJGenerator.apply" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="yaff.pes.generator.MM3Generator">
<em class="property">class </em><tt class="descclassname">yaff.pes.generator.</tt><tt class="descname">MM3Generator</tt><a class="headerlink" href="#yaff.pes.generator.MM3Generator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#yaff.pes.generator.NonbondedGenerator" title="yaff.pes.generator.NonbondedGenerator"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.generator.NonbondedGenerator</span></tt></a></p>
<dl class="attribute">
<dt id="yaff.pes.generator.MM3Generator.prefix">
<tt class="descname">prefix</tt><em class="property"> = 'MM3'</em><a class="headerlink" href="#yaff.pes.generator.MM3Generator.prefix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.MM3Generator.suffixes">
<tt class="descname">suffixes</tt><em class="property"> = ['UNIT', 'SCALE', 'PARS']</em><a class="headerlink" href="#yaff.pes.generator.MM3Generator.suffixes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.MM3Generator.par_info">
<tt class="descname">par_info</tt><em class="property"> = [('SIGMA', &lt;type 'float'&gt;), ('EPSILON', &lt;type 'float'&gt;), ('ONLYPAULI', &lt;type 'int'&gt;)]</em><a class="headerlink" href="#yaff.pes.generator.MM3Generator.par_info" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="yaff.pes.generator.MM3Generator.__call__">
<tt class="descname">__call__</tt><big>(</big><em>system</em>, <em>parsec</em>, <em>ff_args</em><big>)</big><a class="headerlink" href="#yaff.pes.generator.MM3Generator.__call__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="yaff.pes.generator.MM3Generator.apply">
<tt class="descname">apply</tt><big>(</big><em>par_table</em>, <em>scale_table</em>, <em>system</em>, <em>ff_args</em><big>)</big><a class="headerlink" href="#yaff.pes.generator.MM3Generator.apply" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="yaff.pes.generator.ExpRepGenerator">
<em class="property">class </em><tt class="descclassname">yaff.pes.generator.</tt><tt class="descname">ExpRepGenerator</tt><a class="headerlink" href="#yaff.pes.generator.ExpRepGenerator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#yaff.pes.generator.NonbondedGenerator" title="yaff.pes.generator.NonbondedGenerator"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.generator.NonbondedGenerator</span></tt></a></p>
<dl class="attribute">
<dt id="yaff.pes.generator.ExpRepGenerator.prefix">
<tt class="descname">prefix</tt><em class="property"> = 'EXPREP'</em><a class="headerlink" href="#yaff.pes.generator.ExpRepGenerator.prefix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.ExpRepGenerator.suffixes">
<tt class="descname">suffixes</tt><em class="property"> = ['UNIT', 'SCALE', 'MIX', 'PARS', 'CPARS']</em><a class="headerlink" href="#yaff.pes.generator.ExpRepGenerator.suffixes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.ExpRepGenerator.par_info">
<tt class="descname">par_info</tt><em class="property"> = [('A', &lt;type 'float'&gt;), ('B', &lt;type 'float'&gt;)]</em><a class="headerlink" href="#yaff.pes.generator.ExpRepGenerator.par_info" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.ExpRepGenerator.mixing_rules">
<tt class="descname">mixing_rules</tt><em class="property"> = {('B', 'ARITHMETIC_COR'): (1, 1), ('A', 'GEOMETRIC_COR'): (1, 1), ('A', 'GEOMETRIC'): (0, 0), ('B', 'ARITHMETIC'): (0, 0)}</em><a class="headerlink" href="#yaff.pes.generator.ExpRepGenerator.mixing_rules" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="yaff.pes.generator.ExpRepGenerator.__call__">
<tt class="descname">__call__</tt><big>(</big><em>system</em>, <em>parsec</em>, <em>ff_args</em><big>)</big><a class="headerlink" href="#yaff.pes.generator.ExpRepGenerator.__call__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="yaff.pes.generator.ExpRepGenerator.iter_alt_keys">
<tt class="descname">iter_alt_keys</tt><big>(</big><em>key</em><big>)</big><a class="headerlink" href="#yaff.pes.generator.ExpRepGenerator.iter_alt_keys" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="yaff.pes.generator.ExpRepGenerator.apply">
<tt class="descname">apply</tt><big>(</big><em>par_table</em>, <em>cpar_table</em>, <em>scale_table</em>, <em>mixing_rules</em>, <em>system</em>, <em>ff_args</em><big>)</big><a class="headerlink" href="#yaff.pes.generator.ExpRepGenerator.apply" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="yaff.pes.generator.DampDispGenerator">
<em class="property">class </em><tt class="descclassname">yaff.pes.generator.</tt><tt class="descname">DampDispGenerator</tt><a class="headerlink" href="#yaff.pes.generator.DampDispGenerator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#yaff.pes.generator.NonbondedGenerator" title="yaff.pes.generator.NonbondedGenerator"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.generator.NonbondedGenerator</span></tt></a></p>
<dl class="attribute">
<dt id="yaff.pes.generator.DampDispGenerator.prefix">
<tt class="descname">prefix</tt><em class="property"> = 'DAMPDISP'</em><a class="headerlink" href="#yaff.pes.generator.DampDispGenerator.prefix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.DampDispGenerator.suffixes">
<tt class="descname">suffixes</tt><em class="property"> = ['UNIT', 'SCALE', 'PARS', 'CPARS']</em><a class="headerlink" href="#yaff.pes.generator.DampDispGenerator.suffixes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.DampDispGenerator.par_info">
<tt class="descname">par_info</tt><em class="property"> = [('C6', &lt;type 'float'&gt;), ('B', &lt;type 'float'&gt;), ('VOL', &lt;type 'float'&gt;)]</em><a class="headerlink" href="#yaff.pes.generator.DampDispGenerator.par_info" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.DampDispGenerator.cpar_info">
<tt class="descname">cpar_info</tt><em class="property"> = [('C6', &lt;type 'float'&gt;), ('B', &lt;type 'float'&gt;)]</em><a class="headerlink" href="#yaff.pes.generator.DampDispGenerator.cpar_info" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="yaff.pes.generator.DampDispGenerator.__call__">
<tt class="descname">__call__</tt><big>(</big><em>system</em>, <em>parsec</em>, <em>ff_args</em><big>)</big><a class="headerlink" href="#yaff.pes.generator.DampDispGenerator.__call__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="yaff.pes.generator.DampDispGenerator.iter_alt_keys">
<tt class="descname">iter_alt_keys</tt><big>(</big><em>key</em><big>)</big><a class="headerlink" href="#yaff.pes.generator.DampDispGenerator.iter_alt_keys" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="yaff.pes.generator.DampDispGenerator.apply">
<tt class="descname">apply</tt><big>(</big><em>par_table</em>, <em>cpar_table</em>, <em>scale_table</em>, <em>system</em>, <em>ff_args</em><big>)</big><a class="headerlink" href="#yaff.pes.generator.DampDispGenerator.apply" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="yaff.pes.generator.FixedChargeGenerator">
<em class="property">class </em><tt class="descclassname">yaff.pes.generator.</tt><tt class="descname">FixedChargeGenerator</tt><a class="headerlink" href="#yaff.pes.generator.FixedChargeGenerator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#yaff.pes.generator.NonbondedGenerator" title="yaff.pes.generator.NonbondedGenerator"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.generator.NonbondedGenerator</span></tt></a></p>
<dl class="attribute">
<dt id="yaff.pes.generator.FixedChargeGenerator.prefix">
<tt class="descname">prefix</tt><em class="property"> = 'FIXQ'</em><a class="headerlink" href="#yaff.pes.generator.FixedChargeGenerator.prefix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.FixedChargeGenerator.suffixes">
<tt class="descname">suffixes</tt><em class="property"> = ['UNIT', 'SCALE', 'ATOM', 'BOND', 'DIELECTRIC']</em><a class="headerlink" href="#yaff.pes.generator.FixedChargeGenerator.suffixes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="yaff.pes.generator.FixedChargeGenerator.par_info">
<tt class="descname">par_info</tt><em class="property"> = [('Q0', &lt;type 'float'&gt;), ('P', &lt;type 'float'&gt;), ('R', &lt;type 'float'&gt;)]</em><a class="headerlink" href="#yaff.pes.generator.FixedChargeGenerator.par_info" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="yaff.pes.generator.FixedChargeGenerator.__call__">
<tt class="descname">__call__</tt><big>(</big><em>system</em>, <em>parsec</em>, <em>ff_args</em><big>)</big><a class="headerlink" href="#yaff.pes.generator.FixedChargeGenerator.__call__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="yaff.pes.generator.FixedChargeGenerator.process_atoms">
<tt class="descname">process_atoms</tt><big>(</big><em>pardef</em>, <em>conversions</em><big>)</big><a class="headerlink" href="#yaff.pes.generator.FixedChargeGenerator.process_atoms" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="yaff.pes.generator.FixedChargeGenerator.process_bonds">
<tt class="descname">process_bonds</tt><big>(</big><em>pardef</em>, <em>conversions</em><big>)</big><a class="headerlink" href="#yaff.pes.generator.FixedChargeGenerator.process_bonds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="yaff.pes.generator.FixedChargeGenerator.process_dielectric">
<tt class="descname">process_dielectric</tt><big>(</big><em>pardef</em><big>)</big><a class="headerlink" href="#yaff.pes.generator.FixedChargeGenerator.process_dielectric" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="yaff.pes.generator.FixedChargeGenerator.apply">
<tt class="descname">apply</tt><big>(</big><em>atom_table</em>, <em>bond_table</em>, <em>scale_table</em>, <em>dielectric</em>, <em>system</em>, <em>ff_args</em><big>)</big><a class="headerlink" href="#yaff.pes.generator.FixedChargeGenerator.apply" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="yaff.pes.generator.apply_generators">
<tt class="descclassname">yaff.pes.generator.</tt><tt class="descname">apply_generators</tt><big>(</big><em>system</em>, <em>parameters</em>, <em>ff_args</em><big>)</big><a class="headerlink" href="#yaff.pes.generator.apply_generators" title="Permalink to this definition">¶</a></dt>
<dd><p>Populate the attributes of ff_args, prepares arguments for ForceField</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>system</dt>
<dd>A System instance for which the force field object is being made</dd>
<dt>ff_args</dt>
<dd>An instance of the FFArgs class.</dd>
<dt>parameters</dt>
<dd>An instance of the Parameters, typically made by
<tt class="docutils literal"><span class="pre">Parmaeters.from_file('parameters.txt')</span></tt>.</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-yaff.pes.iclist">
<span id="yaff-pes-iclist-internal-coordinate-lists-for-covalent-energy-terms"></span><h2>2.5. <tt class="docutils literal"><span class="pre">yaff.pes.iclist</span></tt> &#8211; Internal-coordinate lists for covalent energy terms<a class="headerlink" href="#module-yaff.pes.iclist" title="Permalink to this headline">¶</a></h2>
<p>Internal-coordinate lists for covalent energy terms</p>
<p>An <tt class="docutils literal"><span class="pre">InternalCoordinateList</span></tt> object contains a table, where each row
corresponds to one internal coordinate. This object also contains a
<a class="reference internal" href="#yaff.pes.dlist.DeltaList" title="yaff.pes.dlist.DeltaList"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.dlist.DeltaList</span></tt></a> object that holds all the input relative
vectors for the internal coordinates.</p>
<p>Each row in the table contains all the information to compute the internal
coordinate with the <tt class="docutils literal"><span class="pre">forward</span></tt> method. Each row can also hold the derivative
of the energy towards the internal coordinate (computed elsewhere), in order
to transform this derivative to derivatives of the energy towards the
relative vectors in the <tt class="docutils literal"><span class="pre">DeltaList</span></tt> object. (See <tt class="docutils literal"><span class="pre">back</span></tt> method.)</p>
<p>Furthermore, a series of <tt class="docutils literal"><span class="pre">InternalCoordinate</span></tt> classes are defined in this
module to facilitate the setup of the table in the <tt class="docutils literal"><span class="pre">InternalCoordinateList</span></tt>
object. An instance of a subclass of <tt class="docutils literal"><span class="pre">InternalCoordinate</span></tt> can be passed
to the <tt class="docutils literal"><span class="pre">add_ic</span></tt> method to register a new internal coordinate in the table.
The <tt class="docutils literal"><span class="pre">add_ic</span></tt> method returns the row index of the internal new coordinate.
If the internal coordinate is already present, no new row is added and the
index of the existing row is returned. When a new internal coordinate is
registered, the required relative vectors are registered automatically in the
<tt class="docutils literal"><span class="pre">DeltaList</span></tt> object.</p>
<p>The class <a class="reference internal" href="#yaff.pes.iclist.InternalCoordinateList" title="yaff.pes.iclist.InternalCoordinateList"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.iclist.InternalCoordinateList</span></tt></a> is intimately
related to classes <a class="reference internal" href="#yaff.pes.dlist.DeltaList" title="yaff.pes.dlist.DeltaList"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.dlist.DeltaList</span></tt></a> and
<a class="reference internal" href="#yaff.pes.vlist.ValenceList" title="yaff.pes.vlist.ValenceList"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.vlist.ValenceList</span></tt></a>. They work together, just like layers in
a neural network, and they use the back-propagation algorithm to compute
partial derivatives. The order of the layers is as follows:</p>
<div class="highlight-python"><pre>DeltaList &lt;--&gt; InternalCoordinateList &lt;--&gt; ValenceList</pre>
</div>
<p>The class <a class="reference internal" href="#yaff.pes.ff.ForcePartValence" title="yaff.pes.ff.ForcePartValence"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.ff.ForcePartValence</span></tt></a> ties these three lists
together. The basic idea of the back-propagation algorithm is explained in
the section <a class="reference internal" href="dg_backprop.html#dg-sec-backprop"><em>The back-propagation algorithm for the computation of energy derivatives</em></a>.</p>
<dl class="class">
<dt id="yaff.pes.iclist.InternalCoordinateList">
<em class="property">class </em><tt class="descclassname">yaff.pes.iclist.</tt><tt class="descname">InternalCoordinateList</tt><big>(</big><em>dlist</em><big>)</big><a class="headerlink" href="#yaff.pes.iclist.InternalCoordinateList" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Contains a table of all internal coordinates used in a covalent force
field. All computations related to internal coordinates are carried out
in coordination with a <tt class="docutils literal"><span class="pre">DeltaList</span></tt> object.</p>
<p><strong>Arugments:</strong></p>
<dl class="docutils">
<dt>dlist</dt>
<dd>An instance of the <tt class="docutils literal"><span class="pre">DeltaList</span></tt> class.</dd>
</dl>
<dl class="method">
<dt id="yaff.pes.iclist.InternalCoordinateList.add_ic">
<tt class="descname">add_ic</tt><big>(</big><em>ic</em><big>)</big><a class="headerlink" href="#yaff.pes.iclist.InternalCoordinateList.add_ic" title="Permalink to this definition">¶</a></dt>
<dd><p>Register a new or find an existing internal coordinate.</p>
<p><strong>Arugments:</strong></p>
<dl class="docutils">
<dt>ic</dt>
<dd>An instance of a subclass of the <tt class="docutils literal"><span class="pre">InternalCoordinate</span></tt> class.</dd>
</dl>
<p>This method returns the row of the new/existing internal coordinate.</p>
</dd></dl>

<dl class="method">
<dt id="yaff.pes.iclist.InternalCoordinateList.forward">
<tt class="descname">forward</tt><big>(</big><big>)</big><a class="headerlink" href="#yaff.pes.iclist.InternalCoordinateList.forward" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the internal coordinates based on the relative vectors in
<tt class="docutils literal"><span class="pre">self.dlist</span></tt>. The result is stored in the table, <tt class="docutils literal"><span class="pre">self.ictab</span></tt>.</p>
<p>The actual computation is carried out by a low-level C routine.</p>
</dd></dl>

<dl class="method">
<dt id="yaff.pes.iclist.InternalCoordinateList.back">
<tt class="descname">back</tt><big>(</big><big>)</big><a class="headerlink" href="#yaff.pes.iclist.InternalCoordinateList.back" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform the derivative of the energy (in <tt class="docutils literal"><span class="pre">self.ictab</span></tt>) to
derivatives of the energy towards the components of the relative
vectors in <tt class="docutils literal"><span class="pre">self.dlist</span></tt>.</p>
<p>The actual computation is carried out by a low-level C routine.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="yaff.pes.iclist.InternalCoordinate">
<em class="property">class </em><tt class="descclassname">yaff.pes.iclist.</tt><tt class="descname">InternalCoordinate</tt><big>(</big><em>index_pairs</em><big>)</big><a class="headerlink" href="#yaff.pes.iclist.InternalCoordinate" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Base class for the internal coordinate &#8216;descriptors&#8217;.</p>
<p>The subclasses are merely used to request a new/existing internal
coordinate in the <tt class="docutils literal"><span class="pre">InternalCoordinateList</span></tt> class. These classes do
not carry out any computations.</p>
<p>The <tt class="docutils literal"><span class="pre">kind</span></tt> class attribute refers to an integer ID that identifies the
internal coordinate kind (bond, angle, ...) in the low-level C code.</p>
<p>Although all of the internal coordinates below are typically associated
with certain topological patterns, one is free to add internal
coordinates that have no direct relation with the molecular topology,
e.g. to define restraints that pull a system over a reaction barrier.</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>index_pairs</dt>
<dd>A list of pairs of atom indexes. Each pair corresponds to
a relative vector used for the computation of the internal
coordinate.</dd>
</dl>
<dl class="attribute">
<dt id="yaff.pes.iclist.InternalCoordinate.kind">
<tt class="descname">kind</tt><em class="property"> = None</em><a class="headerlink" href="#yaff.pes.iclist.InternalCoordinate.kind" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="yaff.pes.iclist.InternalCoordinate.get_rows_signs">
<tt class="descname">get_rows_signs</tt><big>(</big><em>dlist</em><big>)</big><a class="headerlink" href="#yaff.pes.iclist.InternalCoordinate.get_rows_signs" title="Permalink to this definition">¶</a></dt>
<dd><p>Request row indexes and sign flips from a delta list</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>dlist</dt>
<dd>A <tt class="docutils literal"><span class="pre">DeltaList</span></tt> instance.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="yaff.pes.iclist.InternalCoordinate.get_conversion">
<tt class="descname">get_conversion</tt><big>(</big><big>)</big><a class="headerlink" href="#yaff.pes.iclist.InternalCoordinate.get_conversion" title="Permalink to this definition">¶</a></dt>
<dd><p>Auxiliary routine that allows base classes the specify the unit
conversion associated with the internal coordinate.</p>
</dd></dl>

<dl class="method">
<dt id="yaff.pes.iclist.InternalCoordinate.get_log">
<tt class="descname">get_log</tt><big>(</big><big>)</big><a class="headerlink" href="#yaff.pes.iclist.InternalCoordinate.get_log" title="Permalink to this definition">¶</a></dt>
<dd><p>Describe the internal coordinate in a format that is suitable for
screen logging.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="yaff.pes.iclist.Bond">
<em class="property">class </em><tt class="descclassname">yaff.pes.iclist.</tt><tt class="descname">Bond</tt><big>(</big><em>i</em>, <em>j</em><big>)</big><a class="headerlink" href="#yaff.pes.iclist.Bond" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#yaff.pes.iclist.InternalCoordinate" title="yaff.pes.iclist.InternalCoordinate"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.iclist.InternalCoordinate</span></tt></a></p>
<p>Bond length.</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>i, j</dt>
<dd>The indexes of the atoms involved in the covalent bond.</dd>
</dl>
<dl class="attribute">
<dt id="yaff.pes.iclist.Bond.kind">
<tt class="descname">kind</tt><em class="property"> = 0</em><a class="headerlink" href="#yaff.pes.iclist.Bond.kind" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="yaff.pes.iclist.Bond.get_conversion">
<tt class="descname">get_conversion</tt><big>(</big><big>)</big><a class="headerlink" href="#yaff.pes.iclist.Bond.get_conversion" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="yaff.pes.iclist.BendCos">
<em class="property">class </em><tt class="descclassname">yaff.pes.iclist.</tt><tt class="descname">BendCos</tt><big>(</big><em>i</em>, <em>j</em>, <em>k</em><big>)</big><a class="headerlink" href="#yaff.pes.iclist.BendCos" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#yaff.pes.iclist.InternalCoordinate" title="yaff.pes.iclist.InternalCoordinate"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.iclist.InternalCoordinate</span></tt></a></p>
<p>Cosine of a bending (or valence) angle.</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>i, j, k</dt>
<dd>The indexes of the atoms involved in the angle. (i-j-k)</dd>
</dl>
<dl class="attribute">
<dt id="yaff.pes.iclist.BendCos.kind">
<tt class="descname">kind</tt><em class="property"> = 1</em><a class="headerlink" href="#yaff.pes.iclist.BendCos.kind" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="yaff.pes.iclist.BendCos.get_conversion">
<tt class="descname">get_conversion</tt><big>(</big><big>)</big><a class="headerlink" href="#yaff.pes.iclist.BendCos.get_conversion" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="yaff.pes.iclist.BendAngle">
<em class="property">class </em><tt class="descclassname">yaff.pes.iclist.</tt><tt class="descname">BendAngle</tt><big>(</big><em>i</em>, <em>j</em>, <em>k</em><big>)</big><a class="headerlink" href="#yaff.pes.iclist.BendAngle" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#yaff.pes.iclist.InternalCoordinate" title="yaff.pes.iclist.InternalCoordinate"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.iclist.InternalCoordinate</span></tt></a></p>
<p>Bending (or valence) angle.</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>i, j, k</dt>
<dd>The indexes of the atoms involved in the angle. (i-j-k)</dd>
</dl>
<dl class="attribute">
<dt id="yaff.pes.iclist.BendAngle.kind">
<tt class="descname">kind</tt><em class="property"> = 2</em><a class="headerlink" href="#yaff.pes.iclist.BendAngle.kind" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="yaff.pes.iclist.BendAngle.get_conversion">
<tt class="descname">get_conversion</tt><big>(</big><big>)</big><a class="headerlink" href="#yaff.pes.iclist.BendAngle.get_conversion" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="yaff.pes.iclist.DihedCos">
<em class="property">class </em><tt class="descclassname">yaff.pes.iclist.</tt><tt class="descname">DihedCos</tt><big>(</big><em>i</em>, <em>j</em>, <em>k</em>, <em>l</em><big>)</big><a class="headerlink" href="#yaff.pes.iclist.DihedCos" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#yaff.pes.iclist.InternalCoordinate" title="yaff.pes.iclist.InternalCoordinate"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.iclist.InternalCoordinate</span></tt></a></p>
<p>Cosine of a dihedral (or torsion) angle.</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>i, j, k, l</dt>
<dd>The indexes of the atoms involved in the dihedral angle. (i-j-k-l)</dd>
</dl>
<dl class="attribute">
<dt id="yaff.pes.iclist.DihedCos.kind">
<tt class="descname">kind</tt><em class="property"> = 3</em><a class="headerlink" href="#yaff.pes.iclist.DihedCos.kind" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="yaff.pes.iclist.DihedCos.get_conversion">
<tt class="descname">get_conversion</tt><big>(</big><big>)</big><a class="headerlink" href="#yaff.pes.iclist.DihedCos.get_conversion" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="yaff.pes.iclist.DihedAngle">
<em class="property">class </em><tt class="descclassname">yaff.pes.iclist.</tt><tt class="descname">DihedAngle</tt><big>(</big><em>i</em>, <em>j</em>, <em>k</em>, <em>l</em><big>)</big><a class="headerlink" href="#yaff.pes.iclist.DihedAngle" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#yaff.pes.iclist.InternalCoordinate" title="yaff.pes.iclist.InternalCoordinate"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.iclist.InternalCoordinate</span></tt></a></p>
<p>A dihedral (or torsion) angle.</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>i, j, k, l</dt>
<dd>The indexes of the atoms involved in the dihedral angle. (i-j-k-l)</dd>
</dl>
<dl class="attribute">
<dt id="yaff.pes.iclist.DihedAngle.kind">
<tt class="descname">kind</tt><em class="property"> = 4</em><a class="headerlink" href="#yaff.pes.iclist.DihedAngle.kind" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="yaff.pes.iclist.DihedAngle.get_conversion">
<tt class="descname">get_conversion</tt><big>(</big><big>)</big><a class="headerlink" href="#yaff.pes.iclist.DihedAngle.get_conversion" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="yaff.pes.iclist.UreyBradley">
<em class="property">class </em><tt class="descclassname">yaff.pes.iclist.</tt><tt class="descname">UreyBradley</tt><big>(</big><em>i</em>, <em>j</em>, <em>k</em><big>)</big><a class="headerlink" href="#yaff.pes.iclist.UreyBradley" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#yaff.pes.iclist.InternalCoordinate" title="yaff.pes.iclist.InternalCoordinate"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.iclist.InternalCoordinate</span></tt></a></p>
<p>A Urey-Bradley distance, i.e. the distance over a bending angle</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>i, j, k</dt>
<dd>The indexes of the atoms involved in the angle. (i-j-k)</dd>
</dl>
<dl class="attribute">
<dt id="yaff.pes.iclist.UreyBradley.kind">
<tt class="descname">kind</tt><em class="property"> = 5</em><a class="headerlink" href="#yaff.pes.iclist.UreyBradley.kind" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="yaff.pes.iclist.UreyBradley.get_conversion">
<tt class="descname">get_conversion</tt><big>(</big><big>)</big><a class="headerlink" href="#yaff.pes.iclist.UreyBradley.get_conversion" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="yaff.pes.iclist.OopCos">
<em class="property">class </em><tt class="descclassname">yaff.pes.iclist.</tt><tt class="descname">OopCos</tt><big>(</big><em>i</em>, <em>j</em>, <em>k</em>, <em>l</em><big>)</big><a class="headerlink" href="#yaff.pes.iclist.OopCos" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#yaff.pes.iclist.InternalCoordinate" title="yaff.pes.iclist.InternalCoordinate"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.iclist.InternalCoordinate</span></tt></a></p>
<p>Cosine of an out-of-plane angle.</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>i, j, k, l</dt>
<dd>The indexes of the atoms involved in the out-of-plane angle.
The central atom is given by the last index (l). This IC gives
the angle between the plane formed by atoms i, j and l and the
bond between l and k.</dd>
</dl>
<dl class="attribute">
<dt id="yaff.pes.iclist.OopCos.kind">
<tt class="descname">kind</tt><em class="property"> = 6</em><a class="headerlink" href="#yaff.pes.iclist.OopCos.kind" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="yaff.pes.iclist.OopCos.get_conversion">
<tt class="descname">get_conversion</tt><big>(</big><big>)</big><a class="headerlink" href="#yaff.pes.iclist.OopCos.get_conversion" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="yaff.pes.iclist.OopMeanCos">
<em class="property">class </em><tt class="descclassname">yaff.pes.iclist.</tt><tt class="descname">OopMeanCos</tt><big>(</big><em>i</em>, <em>j</em>, <em>k</em>, <em>l</em><big>)</big><a class="headerlink" href="#yaff.pes.iclist.OopMeanCos" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#yaff.pes.iclist.InternalCoordinate" title="yaff.pes.iclist.InternalCoordinate"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.iclist.InternalCoordinate</span></tt></a></p>
<p>Mean of cosines of all 3 out-of-plane angles in a oop pattern.</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>i, j, k, l</dt>
<dd>The indexes of the atoms involved in the out-of-plane angle.
The central atom is given by the last index (l). This IC gives
the angle between the plane formed by atoms i, j and l and the
bond between l and k.</dd>
</dl>
<dl class="attribute">
<dt id="yaff.pes.iclist.OopMeanCos.kind">
<tt class="descname">kind</tt><em class="property"> = 7</em><a class="headerlink" href="#yaff.pes.iclist.OopMeanCos.kind" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="yaff.pes.iclist.OopMeanCos.get_conversion">
<tt class="descname">get_conversion</tt><big>(</big><big>)</big><a class="headerlink" href="#yaff.pes.iclist.OopMeanCos.get_conversion" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="yaff.pes.iclist.OopAngle">
<em class="property">class </em><tt class="descclassname">yaff.pes.iclist.</tt><tt class="descname">OopAngle</tt><big>(</big><em>i</em>, <em>j</em>, <em>k</em>, <em>l</em><big>)</big><a class="headerlink" href="#yaff.pes.iclist.OopAngle" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#yaff.pes.iclist.InternalCoordinate" title="yaff.pes.iclist.InternalCoordinate"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.iclist.InternalCoordinate</span></tt></a></p>
<p>An out-of-plane angle.</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>i, j, k, l</dt>
<dd>The indexes of the atoms involved in the out-of-plane angle.
The central atom is given by the last index (l). This IC gives
the angle between the plane formed by atoms i, j and l and the
bond between l and k.</dd>
</dl>
<dl class="attribute">
<dt id="yaff.pes.iclist.OopAngle.kind">
<tt class="descname">kind</tt><em class="property"> = 8</em><a class="headerlink" href="#yaff.pes.iclist.OopAngle.kind" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="yaff.pes.iclist.OopAngle.get_conversion">
<tt class="descname">get_conversion</tt><big>(</big><big>)</big><a class="headerlink" href="#yaff.pes.iclist.OopAngle.get_conversion" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="yaff.pes.iclist.OopMeanAngle">
<em class="property">class </em><tt class="descclassname">yaff.pes.iclist.</tt><tt class="descname">OopMeanAngle</tt><big>(</big><em>i</em>, <em>j</em>, <em>k</em>, <em>l</em><big>)</big><a class="headerlink" href="#yaff.pes.iclist.OopMeanAngle" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#yaff.pes.iclist.InternalCoordinate" title="yaff.pes.iclist.InternalCoordinate"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.iclist.InternalCoordinate</span></tt></a></p>
<p>Mean of all 3 out-of-plane angles in an oop pattern.</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>i, j, k, l</dt>
<dd>The indexes of the atoms involved in the out-of-plane angle.
The central atom is given by the last index (l). This IC gives
the angle between the plane formed by atoms i, j and l and the
bond between l and k.</dd>
</dl>
<dl class="attribute">
<dt id="yaff.pes.iclist.OopMeanAngle.kind">
<tt class="descname">kind</tt><em class="property"> = 9</em><a class="headerlink" href="#yaff.pes.iclist.OopMeanAngle.kind" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="yaff.pes.iclist.OopMeanAngle.get_conversion">
<tt class="descname">get_conversion</tt><big>(</big><big>)</big><a class="headerlink" href="#yaff.pes.iclist.OopMeanAngle.get_conversion" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="yaff.pes.iclist.OopDist">
<em class="property">class </em><tt class="descclassname">yaff.pes.iclist.</tt><tt class="descname">OopDist</tt><big>(</big><em>i</em>, <em>j</em>, <em>k</em>, <em>l</em><big>)</big><a class="headerlink" href="#yaff.pes.iclist.OopDist" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#yaff.pes.iclist.InternalCoordinate" title="yaff.pes.iclist.InternalCoordinate"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.iclist.InternalCoordinate</span></tt></a></p>
<p>Distance from an atom to the plane formed by three other atoms</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>i, j, k, l</dt>
<dd>The indexes of the atoms involved in the out-of-plane distance.
The central atom is given by the last index (l). The plane is
formed by the other three atoms i,j and k.</dd>
</dl>
<dl class="attribute">
<dt id="yaff.pes.iclist.OopDist.kind">
<tt class="descname">kind</tt><em class="property"> = 10</em><a class="headerlink" href="#yaff.pes.iclist.OopDist.kind" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="yaff.pes.iclist.OopDist.get_conversion">
<tt class="descname">get_conversion</tt><big>(</big><big>)</big><a class="headerlink" href="#yaff.pes.iclist.OopDist.get_conversion" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-yaff.pes.nlist">
<span id="yaff-pes-nlist-neighbor-lists-for-pairwise-non-bonding-interactions"></span><h2>2.6. <tt class="docutils literal"><span class="pre">yaff.pes.nlist</span></tt> &#8211; Neighbor lists for pairwise (non-bonding) interactions<a class="headerlink" href="#module-yaff.pes.nlist" title="Permalink to this headline">¶</a></h2>
<p>Neighbor lists for pairwise (non-bonding) interactions</p>
<p>Yaff works with half neighbor lists with relative vector information and with
support for Verlet skin.</p>
<p>Yaff supports only one neighbor list, which is used to evaluate all
non-bonding interactions. The neighbor list is used by the <tt class="docutils literal"><span class="pre">ForcePartPair</span></tt>
objects. Each <tt class="docutils literal"><span class="pre">ForcePartPair</span></tt> object may have a different cutoff, of which
the largest one determines the cutoff of the neighbor list. Unlike several
other codes, Yaff uses one long neighbor list that contains all relevant atom
pairs.</p>
<p>The <tt class="docutils literal"><span class="pre">NeighborList</span></tt> object contains algorithms to detect whether a full rebuild
of the neighbor list is required, or whether a recomputation of the distances
and relative vectors is sufficient.</p>
<dl class="class">
<dt id="yaff.pes.nlist.NeighborList">
<em class="property">class </em><tt class="descclassname">yaff.pes.nlist.</tt><tt class="descname">NeighborList</tt><big>(</big><em>system</em>, <em>skin=0</em><big>)</big><a class="headerlink" href="#yaff.pes.nlist.NeighborList" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Algorithms to keep track of all pair distances below a given rcut</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>system</dt>
<dd>A System instance.</dd>
</dl>
<p><strong>Optional arguments:</strong></p>
<dl class="docutils">
<dt>skin</dt>
<dd><p class="first">A margin added to the rcut parameter. Only when atoms are
displaced by half this distance, the neighbor list is rebuilt
from scratch. In the other case, the distances of the known
pairs are just recomputed. If set to zero, the default, the
neighbor list is rebuilt at each update.</p>
<p class="last">A reasonable skin setting can drastically improve the
performance of the neighbor list updates. For example, when
<tt class="docutils literal"><span class="pre">rcut</span></tt> is <tt class="docutils literal"><span class="pre">10*angstrom</span></tt>, a <tt class="docutils literal"><span class="pre">skin</span></tt> of <tt class="docutils literal"><span class="pre">2*angstrom</span></tt> is
reasonable. If the skin is set too large, the updates will
become very inefficient. Some tuning of <tt class="docutils literal"><span class="pre">rcut</span></tt> and <tt class="docutils literal"><span class="pre">skin</span></tt>
may be beneficial.</p>
</dd>
</dl>
<dl class="method">
<dt id="yaff.pes.nlist.NeighborList.check">
<tt class="descname">check</tt><big>(</big><big>)</big><a class="headerlink" href="#yaff.pes.nlist.NeighborList.check" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a slow internal consistency test.</p>
<p>Use this for debugging only. It is assumed that self.rmax is set correctly.</p>
</dd></dl>

<dl class="method">
<dt id="yaff.pes.nlist.NeighborList.request_rcut">
<tt class="descname">request_rcut</tt><big>(</big><em>rcut</em><big>)</big><a class="headerlink" href="#yaff.pes.nlist.NeighborList.request_rcut" title="Permalink to this definition">¶</a></dt>
<dd><p>Make sure the internal rcut parameter is at least is high as rcut.</p>
</dd></dl>

<dl class="method">
<dt id="yaff.pes.nlist.NeighborList.to_dictionary">
<tt class="descname">to_dictionary</tt><big>(</big><big>)</big><a class="headerlink" href="#yaff.pes.nlist.NeighborList.to_dictionary" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform current neighbor list into a dictionary.</p>
<p>This is slow. Use this method for debugging only!</p>
</dd></dl>

<dl class="method">
<dt id="yaff.pes.nlist.NeighborList.update">
<tt class="descname">update</tt><big>(</big><big>)</big><a class="headerlink" href="#yaff.pes.nlist.NeighborList.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Rebuild or recompute the neighbor lists</p>
<p>Based on the changes of the atomic positions or due to calls to
<tt class="docutils literal"><span class="pre">update_rcut</span></tt> and <tt class="docutils literal"><span class="pre">update_rmax</span></tt>, the neighbor lists will be
rebuilt from scratch.</p>
<p>The heavy computational work is done in low-level C routines. The
neighbor lists array is reallocated if needed. The memory allocation
is done in Python for convenience.</p>
</dd></dl>

<dl class="method">
<dt id="yaff.pes.nlist.NeighborList.update_rmax">
<tt class="descname">update_rmax</tt><big>(</big><big>)</big><a class="headerlink" href="#yaff.pes.nlist.NeighborList.update_rmax" title="Permalink to this definition">¶</a></dt>
<dd><p>Recompute the <tt class="docutils literal"><span class="pre">rmax</span></tt> attribute.</p>
<p><tt class="docutils literal"><span class="pre">rmax</span></tt> determines the number of periodic images that are
considered. when building the neighbor list. Along the a direction,
images are taken from <tt class="docutils literal"><span class="pre">-rmax[0]</span></tt> to <tt class="docutils literal"><span class="pre">rmax[0]</span></tt> (inclusive). The
range of images along the b and c direction are controlled by
<tt class="docutils literal"><span class="pre">rmax[1]</span></tt> and <tt class="docutils literal"><span class="pre">rmax[2]</span></tt>, respectively.</p>
<p>Updating <tt class="docutils literal"><span class="pre">rmax</span></tt> may be necessary for two reasons: (i) the cutoff
has changed, and (ii) the cell vectors have changed.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-yaff.pes.parameters">
<span id="yaff-pes-parameters-object-oriented-representation-of-parameter-files"></span><h2>2.7. <tt class="docutils literal"><span class="pre">yaff.pes.parameters</span></tt> &#8211; Object-oriented representation of parameter files<a class="headerlink" href="#module-yaff.pes.parameters" title="Permalink to this headline">¶</a></h2>
<p>Object-oriented representation of parameter files</p>
<dl class="class">
<dt id="yaff.pes.parameters.Complain">
<em class="property">class </em><tt class="descclassname">yaff.pes.parameters.</tt><tt class="descname">Complain</tt><big>(</big><em>filename='__nofile__'</em><big>)</big><a class="headerlink" href="#yaff.pes.parameters.Complain" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Class for complain method of ParameterFile and ParameterSection</p>
<dl class="method">
<dt id="yaff.pes.parameters.Complain.__call__">
<tt class="descname">__call__</tt><big>(</big><em>counter</em>, <em>message</em><big>)</big><a class="headerlink" href="#yaff.pes.parameters.Complain.__call__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="yaff.pes.parameters.Parameters">
<em class="property">class </em><tt class="descclassname">yaff.pes.parameters.</tt><tt class="descname">Parameters</tt><big>(</big><em>sections=None</em><big>)</big><a class="headerlink" href="#yaff.pes.parameters.Parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Object that represents a force field parameter file</p>
<p>The parameter file is first parsed by this object into a convenient
data structure with dictionaries. The actual force field is then
generated based on these dictionaries.</p>
<p>The parameter file has a purely line-based syntax. The order of the lines
has no meaning. Comments begin with a hash sign (#) and continue till the
end of a line. If the line is empty after stripping the comments, it is
ignored. Every non-empty line should have the following format:</p>
<p>PREFIX:SUFFIX DATA</p>
<p>The prefix is used for sections, the suffix for definitions and the
remainder of the line contains arguments for the definition. Definitions
may be repeated with different or the same arguments.</p>
<dl class="classmethod">
<dt id="yaff.pes.parameters.Parameters.from_file">
<em class="property">classmethod </em><tt class="descname">from_file</tt><big>(</big><em>filenames</em><big>)</big><a class="headerlink" href="#yaff.pes.parameters.Parameters.from_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a Parameters instance from one or more text files.</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>filenames</dt>
<dd>A single filename or a list of filenames</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="yaff.pes.parameters.Parameters.copy">
<tt class="descname">copy</tt><big>(</big><big>)</big><a class="headerlink" href="#yaff.pes.parameters.Parameters.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an independent copy</p>
</dd></dl>

<dl class="method">
<dt id="yaff.pes.parameters.Parameters.write_to_file">
<tt class="descname">write_to_file</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#yaff.pes.parameters.Parameters.write_to_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the parameters back to a file</p>
<p>The outut file will not contain any comments.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="yaff.pes.parameters.ParameterSection">
<em class="property">class </em><tt class="descclassname">yaff.pes.parameters.</tt><tt class="descname">ParameterSection</tt><big>(</big><em>prefix</em>, <em>definitions=None</em>, <em>complain=None</em><big>)</big><a class="headerlink" href="#yaff.pes.parameters.ParameterSection" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Object that represents one section in a force field parameter file</p>
<dl class="method">
<dt id="yaff.pes.parameters.ParameterSection.copy">
<tt class="descname">copy</tt><big>(</big><big>)</big><a class="headerlink" href="#yaff.pes.parameters.ParameterSection.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an independent copy</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="yaff.pes.parameters.ParameterDefinition">
<em class="property">class </em><tt class="descclassname">yaff.pes.parameters.</tt><tt class="descname">ParameterDefinition</tt><big>(</big><em>suffix</em>, <em>lines=None</em>, <em>complain=None</em><big>)</big><a class="headerlink" href="#yaff.pes.parameters.ParameterDefinition" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Object that represents a set of data lines from a parameter file</p>
<dl class="method">
<dt id="yaff.pes.parameters.ParameterDefinition.copy">
<tt class="descname">copy</tt><big>(</big><big>)</big><a class="headerlink" href="#yaff.pes.parameters.ParameterDefinition.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-yaff.pes.scaling">
<span id="yaff-pes-scaling-short-range-scaling-of-pairwise-interactions"></span><h2>2.8. <tt class="docutils literal"><span class="pre">yaff.pes.scaling</span></tt> &#8211; Short-range scaling of pairwise interactions<a class="headerlink" href="#module-yaff.pes.scaling" title="Permalink to this headline">¶</a></h2>
<p>Short-range scaling of pairwise interactions</p>
<p>The <tt class="docutils literal"><span class="pre">Scalings</span></tt> class describe scaling or exclusion of short-range
non-bonding pairwise interactions for atom pairs that are involved in
covalent energy terms.</p>
<p>A <tt class="docutils literal"><span class="pre">Scaling</span></tt> object can be attached to any <tt class="docutils literal"><span class="pre">ForcePartPair</span></tt> class and,
as a special case, also to the <tt class="docutils literal"><span class="pre">ForcePartEwaldCorrection</span></tt>. A <tt class="docutils literal"><span class="pre">Scaling</span></tt>
object describes which 1-2 (scale1), 1-3 (scale2) and 1-4 (scale3) pairs
should have their interactions scaled down or excluded (scaling=0.0).</p>
<p>In order to avoid ambiguities, each scaled pair should only correspond to
one unique bond path to the periodic image. If this is not the case an
<tt class="docutils literal"><span class="pre">AssertionError</span></tt> is raised to inform the user that he/she should switch to
a larger supercell. Yaff can simply not handle such cases correctly. (The
same problem may be present in other codes, but we do not know to what extent
they handle such cases gracefully.)</p>
<dl class="class">
<dt id="yaff.pes.scaling.Scalings">
<em class="property">class </em><tt class="descclassname">yaff.pes.scaling.</tt><tt class="descname">Scalings</tt><big>(</big><em>system</em>, <em>scale1=0.0</em>, <em>scale2=0.0</em>, <em>scale3=1.0</em><big>)</big><a class="headerlink" href="#yaff.pes.scaling.Scalings" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Describes the scaling of short-range pairwise interactions for atom pairs
involved in covalent energy terms.</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>system</dt>
<dd>The system to which the scaling rules apply.</dd>
<dt>scale1, scale2, scale3</dt>
<dd>The scaling of the 1-2. 1-3 and 1-4 pairs, respectively.</dd>
</dl>
<dl class="method">
<dt id="yaff.pes.scaling.Scalings.check_mic">
<tt class="descname">check_mic</tt><big>(</big><em>system</em><big>)</big><a class="headerlink" href="#yaff.pes.scaling.Scalings.check_mic" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if each scale2 and scale3 are uniquely defined.</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>system</dt>
<dd>An instance of the system class, i.e. the one that is used to
create this scaling object.</dd>
</dl>
<p>This check is done by constructing for each scaled pair, all possible
bond paths between the two atoms. For each path, the bond vectors
(after applying the minimum image convention) are added. If for a
given pair, these sums of bond vectors differ between all possible
paths, the differences are expanded in cell vectors which can be used
to construct a proper supercell in which scale2 and scale3 pairs are
all uniquely defined.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="yaff.pes.scaling.iter_paths">
<tt class="descclassname">yaff.pes.scaling.</tt><tt class="descname">iter_paths</tt><big>(</big><em>system</em>, <em>ib</em>, <em>ie</em>, <em>nbond</em><big>)</big><a class="headerlink" href="#yaff.pes.scaling.iter_paths" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterates over all paths between atoms <tt class="docutils literal"><span class="pre">ib</span></tt> and <tt class="docutils literal"><span class="pre">ie</span></tt> with the given
number of bonds</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>system</dt>
<dd>The system that contains the bond graph</dd>
<dt>ib, ie</dt>
<dd>The indexes of the beginning and end atoms.</dd>
<dt>nbond</dt>
<dd>The length of the path, in number of bonds.</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-yaff.pes.vlist">
<span id="yaff-pes-vlist-module-for-the-complete-list-of-covalent-energy-terms"></span><h2>2.9. <tt class="docutils literal"><span class="pre">yaff.pes.vlist</span></tt> &#8211; Module for the complete list of covalent energy terms.<a class="headerlink" href="#module-yaff.pes.vlist" title="Permalink to this headline">¶</a></h2>
<p>Module for the complete list of covalent energy terms.</p>
<p>A <tt class="docutils literal"><span class="pre">ValenceList</span></tt> object contains a table with all the energy terms that
contribute (additively) to the total energy. The values of the internal
coordinates, needed to compute the energy, are taken from an
<a class="reference internal" href="#yaff.pes.iclist.InternalCoordinateList" title="yaff.pes.iclist.InternalCoordinateList"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.iclist.InternalCoordinateList</span></tt></a> class.</p>
<p>Each row in the table contains all the information to evaluate one energy
term, which is done by the <tt class="docutils literal"><span class="pre">forward</span></tt> method. The <tt class="docutils literal"><span class="pre">back</span></tt> method <strong>adds</strong>
the derivative of the energy towards the internal coordinate to the right
entry in the <tt class="docutils literal"><span class="pre">InternalCoordinateList</span></tt> object.</p>
<p>A series of <tt class="docutils literal"><span class="pre">ValenceTerm</span></tt> classes is defined. These are used to register
new energy terms in a <tt class="docutils literal"><span class="pre">ValenceList</span></tt> object. Each subclass of <tt class="docutils literal"><span class="pre">ValenceList</span></tt>
represents a kind of energy term, e.g. harmonic, Fues, class-2 cross term,
etc. Instances of these classes are passed to the <tt class="docutils literal"><span class="pre">add_term</span></tt> method,
which will append a new row to the table and register the required
internal coordinates in the <tt class="docutils literal"><span class="pre">InternalCoordinateList</span></tt> object. (That will
in turn register the requires relative vectors in a <tt class="docutils literal"><span class="pre">DeltaList</span></tt> object.)</p>
<p>The class <a class="reference internal" href="#yaff.pes.vlist.ValenceList" title="yaff.pes.vlist.ValenceList"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.vlist.ValenceList</span></tt></a> is intimately related to
classes <a class="reference internal" href="#yaff.pes.dlist.DeltaList" title="yaff.pes.dlist.DeltaList"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.dlist.DeltaList</span></tt></a> and
<a class="reference internal" href="#yaff.pes.iclist.InternalCoordinateList" title="yaff.pes.iclist.InternalCoordinateList"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.iclist.InternalCoordinateList</span></tt></a>. They work together, just
like layers in a neural network, and they use the back-propagation algorithm
to compute partial derivatives. The order of the layers is as follows:</p>
<div class="highlight-python"><pre>DeltaList &lt;--&gt; InternalCoordinateList &lt;--&gt; ValenceList</pre>
</div>
<p>The class <a class="reference internal" href="#yaff.pes.ff.ForcePartValence" title="yaff.pes.ff.ForcePartValence"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.ff.ForcePartValence</span></tt></a> ties these three lists
together. The basic idea of the back-propagation algorithm is explained in
the section <a class="reference internal" href="dg_backprop.html#dg-sec-backprop"><em>The back-propagation algorithm for the computation of energy derivatives</em></a>.</p>
<dl class="class">
<dt id="yaff.pes.vlist.ValenceList">
<em class="property">class </em><tt class="descclassname">yaff.pes.vlist.</tt><tt class="descname">ValenceList</tt><big>(</big><em>iclist</em><big>)</big><a class="headerlink" href="#yaff.pes.vlist.ValenceList" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Contains a complete list of all valence energy terms. Computations are
carried out in coordination with an <tt class="docutils literal"><span class="pre">InternalCoordinateList</span></tt> object.</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>iclist</dt>
<dd>An instance of the <tt class="docutils literal"><span class="pre">InternalCoordinateList</span></tt> object.</dd>
</dl>
<dl class="method">
<dt id="yaff.pes.vlist.ValenceList.add_term">
<tt class="descname">add_term</tt><big>(</big><em>term</em><big>)</big><a class="headerlink" href="#yaff.pes.vlist.ValenceList.add_term" title="Permalink to this definition">¶</a></dt>
<dd><p>Register a new covalent energy term</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>term</dt>
<dd>An instance of a subclass of the <tt class="docutils literal"><span class="pre">ValenceTerm</span></tt> class.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="yaff.pes.vlist.ValenceList.forward">
<tt class="descname">forward</tt><big>(</big><big>)</big><a class="headerlink" href="#yaff.pes.vlist.ValenceList.forward" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the values of the energy terms, based on the values of the
internal coordinates list, and store the result in the <tt class="docutils literal"><span class="pre">self.vtab</span></tt>
table.</p>
<p>The actual computation is carried out by a low-level C routine.</p>
</dd></dl>

<dl class="method">
<dt id="yaff.pes.vlist.ValenceList.back">
<tt class="descname">back</tt><big>(</big><big>)</big><a class="headerlink" href="#yaff.pes.vlist.ValenceList.back" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the derivatives of the energy terms towards the internal
coordinates and store the results in the <tt class="docutils literal"><span class="pre">self.iclist.ictab</span></tt> table.</p>
<p>The actual computation is carried out by a low-level C routine.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="yaff.pes.vlist.ValenceTerm">
<em class="property">class </em><tt class="descclassname">yaff.pes.vlist.</tt><tt class="descname">ValenceTerm</tt><big>(</big><em>pars</em>, <em>ics</em><big>)</big><a class="headerlink" href="#yaff.pes.vlist.ValenceTerm" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Base class for valence energy terms &#8216;descriptors&#8217;.</p>
<p>The subclasses are merely used to request a new covalent energy terms in
the <tt class="docutils literal"><span class="pre">ValenceList</span></tt> class. These classes do not carry out any
computations.</p>
<p>The <tt class="docutils literal"><span class="pre">kind</span></tt> class attribute refers to an integer ID that identifies the
valence term kind (harmonic, fues, ...) in the low-level C code.</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>pars</dt>
<dd>A list of parameters to be stored for this energy term. This list
may at most contain four elements.</dd>
<dt>ics</dt>
<dd>A list of row indexes in the table of internal coordinates. This
list may contain either one or two elements.</dd>
</dl>
<dl class="attribute">
<dt id="yaff.pes.vlist.ValenceTerm.kind">
<tt class="descname">kind</tt><em class="property"> = None</em><a class="headerlink" href="#yaff.pes.vlist.ValenceTerm.kind" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="yaff.pes.vlist.ValenceTerm.get_ic_indexes">
<tt class="descname">get_ic_indexes</tt><big>(</big><em>iclist</em><big>)</big><a class="headerlink" href="#yaff.pes.vlist.ValenceTerm.get_ic_indexes" title="Permalink to this definition">¶</a></dt>
<dd><p>Request row indexes for the internal coordinates from the given
<tt class="docutils literal"><span class="pre">InternalCoordinateList</span></tt> object.</p>
</dd></dl>

<dl class="method">
<dt id="yaff.pes.vlist.ValenceTerm.get_log">
<tt class="descname">get_log</tt><big>(</big><big>)</big><a class="headerlink" href="#yaff.pes.vlist.ValenceTerm.get_log" title="Permalink to this definition">¶</a></dt>
<dd><p>Describe the covalent energy term in a format that is suitable for
screen logging.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="yaff.pes.vlist.Harmonic">
<em class="property">class </em><tt class="descclassname">yaff.pes.vlist.</tt><tt class="descname">Harmonic</tt><big>(</big><em>fc</em>, <em>rv</em>, <em>ic</em><big>)</big><a class="headerlink" href="#yaff.pes.vlist.Harmonic" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#yaff.pes.vlist.ValenceTerm" title="yaff.pes.vlist.ValenceTerm"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.vlist.ValenceTerm</span></tt></a></p>
<p>The harmonic energy term: 0.5*K*(q-q0)^2</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>fc</dt>
<dd>The force constant (in atomic units).</dd>
<dt>rv</dt>
<dd>The rest value (in atomic units).</dd>
<dt>ic</dt>
<dd>An <tt class="docutils literal"><span class="pre">InternalCoordinate</span></tt> object.</dd>
</dl>
<dl class="attribute">
<dt id="yaff.pes.vlist.Harmonic.kind">
<tt class="descname">kind</tt><em class="property"> = 0</em><a class="headerlink" href="#yaff.pes.vlist.Harmonic.kind" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="yaff.pes.vlist.Harmonic.get_log">
<tt class="descname">get_log</tt><big>(</big><big>)</big><a class="headerlink" href="#yaff.pes.vlist.Harmonic.get_log" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="yaff.pes.vlist.PolyFour">
<em class="property">class </em><tt class="descclassname">yaff.pes.vlist.</tt><tt class="descname">PolyFour</tt><big>(</big><em>pars</em>, <em>ic</em><big>)</big><a class="headerlink" href="#yaff.pes.vlist.PolyFour" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#yaff.pes.vlist.ValenceTerm" title="yaff.pes.vlist.ValenceTerm"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.vlist.ValenceTerm</span></tt></a></p>
<p>Fourth-order polynomical term: par0*q + par1*q^2 + par2*q^3 + par3*q^4</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>pars</dt>
<dd>The constant linear coefficients of the polynomial, in atomic
units, starting from first order. This list may at most contain
four coefficients.</dd>
<dt>ic</dt>
<dd>An <tt class="docutils literal"><span class="pre">InternalCoordinate</span></tt> object.</dd>
</dl>
<dl class="attribute">
<dt id="yaff.pes.vlist.PolyFour.kind">
<tt class="descname">kind</tt><em class="property"> = 1</em><a class="headerlink" href="#yaff.pes.vlist.PolyFour.kind" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="yaff.pes.vlist.PolyFour.get_log">
<tt class="descname">get_log</tt><big>(</big><big>)</big><a class="headerlink" href="#yaff.pes.vlist.PolyFour.get_log" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="yaff.pes.vlist.Fues">
<em class="property">class </em><tt class="descclassname">yaff.pes.vlist.</tt><tt class="descname">Fues</tt><big>(</big><em>fc</em>, <em>rv</em>, <em>ic</em><big>)</big><a class="headerlink" href="#yaff.pes.vlist.Fues" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#yaff.pes.vlist.ValenceTerm" title="yaff.pes.vlist.ValenceTerm"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.vlist.ValenceTerm</span></tt></a></p>
<p>The Fues energy term: 0.5*K*q0^2*(1-q/q0)^2</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>fc</dt>
<dd>The force constant (in atomic units).</dd>
<dt>rv</dt>
<dd>The rest value (in atomic units).</dd>
<dt>ic</dt>
<dd>An <tt class="docutils literal"><span class="pre">InternalCoordinate</span></tt> object.</dd>
</dl>
<dl class="attribute">
<dt id="yaff.pes.vlist.Fues.kind">
<tt class="descname">kind</tt><em class="property"> = 2</em><a class="headerlink" href="#yaff.pes.vlist.Fues.kind" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="yaff.pes.vlist.Fues.get_log">
<tt class="descname">get_log</tt><big>(</big><big>)</big><a class="headerlink" href="#yaff.pes.vlist.Fues.get_log" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="yaff.pes.vlist.Cross">
<em class="property">class </em><tt class="descclassname">yaff.pes.vlist.</tt><tt class="descname">Cross</tt><big>(</big><em>fc</em>, <em>rv0</em>, <em>rv1</em>, <em>ic0</em>, <em>ic1</em><big>)</big><a class="headerlink" href="#yaff.pes.vlist.Cross" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#yaff.pes.vlist.ValenceTerm" title="yaff.pes.vlist.ValenceTerm"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.vlist.ValenceTerm</span></tt></a></p>
<p>A traditional class-2 cross term: K*(x-x0)*(y-y0)</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>fc</dt>
<dd>The force constant (in atomic units).</dd>
<dt>rv0, rv1</dt>
<dd>The rest values (in atomic units).</dd>
<dt>ic0, ic1</dt>
<dd>The <tt class="docutils literal"><span class="pre">InternalCoordinate</span></tt> objects. ic0 corresponds to rv0, and
ic1 corresponds to rv1.</dd>
</dl>
<dl class="attribute">
<dt id="yaff.pes.vlist.Cross.kind">
<tt class="descname">kind</tt><em class="property"> = 3</em><a class="headerlink" href="#yaff.pes.vlist.Cross.kind" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="yaff.pes.vlist.Cross.get_log">
<tt class="descname">get_log</tt><big>(</big><big>)</big><a class="headerlink" href="#yaff.pes.vlist.Cross.get_log" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="yaff.pes.vlist.Cosine">
<em class="property">class </em><tt class="descclassname">yaff.pes.vlist.</tt><tt class="descname">Cosine</tt><big>(</big><em>m</em>, <em>a</em>, <em>phi0</em>, <em>ic</em><big>)</big><a class="headerlink" href="#yaff.pes.vlist.Cosine" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#yaff.pes.vlist.ValenceTerm" title="yaff.pes.vlist.ValenceTerm"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.vlist.ValenceTerm</span></tt></a></p>
<p>A cosine energy term: 0.5*a*(1-cos(m*(phi-phi0)))</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>m</dt>
<dd>The multiplicity of the cosine function, which may be useful
for torsional barriers.</dd>
<dt>a</dt>
<dd>The amplitude of the cosine function (in atomic units).</dd>
<dt>phi0</dt>
<dd>The rest angle of cosine term (in radians).</dd>
<dt>ic</dt>
<dd>An <tt class="docutils literal"><span class="pre">InternalCoordinate</span></tt> object. This must be an internal
coordinate that computes some angle in radians.</dd>
</dl>
<dl class="attribute">
<dt id="yaff.pes.vlist.Cosine.kind">
<tt class="descname">kind</tt><em class="property"> = 4</em><a class="headerlink" href="#yaff.pes.vlist.Cosine.kind" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="yaff.pes.vlist.Cosine.get_log">
<tt class="descname">get_log</tt><big>(</big><big>)</big><a class="headerlink" href="#yaff.pes.vlist.Cosine.get_log" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="yaff.pes.vlist.Chebychev1">
<em class="property">class </em><tt class="descclassname">yaff.pes.vlist.</tt><tt class="descname">Chebychev1</tt><big>(</big><em>A</em>, <em>ic</em>, <em>sign=-1</em><big>)</big><a class="headerlink" href="#yaff.pes.vlist.Chebychev1" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#yaff.pes.vlist.ValenceTerm" title="yaff.pes.vlist.ValenceTerm"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.vlist.ValenceTerm</span></tt></a></p>
<p>A first degree polynomial: 0.5*A*(1 -+ T1)
where T1=x is the first Chebychev polynomial of the first kind.</p>
<p>This is used for a computationally efficient implementation of torsional
energy terms, because the only computation of the cosine of the dihedral
angle is needed, not the angle itself.</p>
<p>This term corresponds to multiplicity 1. The minus sign corresponds to a
rest value of 0 degrees. With a the plus sign, the rest value becomes
180 degrees.</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>A</dt>
<dd>The energy scale of the function (in atomic units).</dd>
<dt>ic</dt>
<dd>An <tt class="docutils literal"><span class="pre">InternalCoordinate</span></tt> object.</dd>
<dt>sign</dt>
<dd>Choose positive or negative sign in the polynomial.</dd>
</dl>
<dl class="attribute">
<dt id="yaff.pes.vlist.Chebychev1.kind">
<tt class="descname">kind</tt><em class="property"> = 5</em><a class="headerlink" href="#yaff.pes.vlist.Chebychev1.kind" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="yaff.pes.vlist.Chebychev1.get_log">
<tt class="descname">get_log</tt><big>(</big><big>)</big><a class="headerlink" href="#yaff.pes.vlist.Chebychev1.get_log" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="yaff.pes.vlist.Chebychev2">
<em class="property">class </em><tt class="descclassname">yaff.pes.vlist.</tt><tt class="descname">Chebychev2</tt><big>(</big><em>A</em>, <em>ic</em>, <em>sign=-1</em><big>)</big><a class="headerlink" href="#yaff.pes.vlist.Chebychev2" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#yaff.pes.vlist.ValenceTerm" title="yaff.pes.vlist.ValenceTerm"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.vlist.ValenceTerm</span></tt></a></p>
<p>A second degree polynomial: 0.5*A*(1 -+ T2)
where T2=2*x**2-1 is the second Chebychev polynomial of the first kind.</p>
<p>This is used for a computationally efficient implementation of torsional
energy terms, because the only computation of the cosine of the dihedral
angle is needed, not the angle itself.</p>
<p>This term corresponds to multiplicity 2. The minus sign corresponds to a
rest value of 0 degrees. With a the plus sign, the rest value becomes
90 degrees.</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>A</dt>
<dd>The energy scale of the function (in atomic units).</dd>
<dt>ic</dt>
<dd>An <tt class="docutils literal"><span class="pre">InternalCoordinate</span></tt> object.</dd>
<dt>sign</dt>
<dd>Choose positive or negative sign in the polynomial.</dd>
</dl>
<dl class="attribute">
<dt id="yaff.pes.vlist.Chebychev2.kind">
<tt class="descname">kind</tt><em class="property"> = 6</em><a class="headerlink" href="#yaff.pes.vlist.Chebychev2.kind" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="yaff.pes.vlist.Chebychev2.get_log">
<tt class="descname">get_log</tt><big>(</big><big>)</big><a class="headerlink" href="#yaff.pes.vlist.Chebychev2.get_log" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="yaff.pes.vlist.Chebychev3">
<em class="property">class </em><tt class="descclassname">yaff.pes.vlist.</tt><tt class="descname">Chebychev3</tt><big>(</big><em>A</em>, <em>ic</em>, <em>sign=-1</em><big>)</big><a class="headerlink" href="#yaff.pes.vlist.Chebychev3" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#yaff.pes.vlist.ValenceTerm" title="yaff.pes.vlist.ValenceTerm"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.vlist.ValenceTerm</span></tt></a></p>
<p>A third degree polynomial: 0.5*A*(1 -+ T3)
where T3=4*x**3-3*x is the third Chebychev polynomial of the first kind.</p>
<p>This is used for a computationally efficient implementation of torsional
energy terms, because the only computation of the cosine of the dihedral
angle is needed, not the angle itself.</p>
<p>This term corresponds to multiplicity 3. The minus sign corresponds to a
rest value of 0 degrees. With a the plus sign, the rest value becomes
60 degrees.</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>A</dt>
<dd>The energy scale of the function (in atomic units).</dd>
<dt>ic</dt>
<dd>An <tt class="docutils literal"><span class="pre">InternalCoordinate</span></tt> object.</dd>
<dt>sign</dt>
<dd>Choose positive or negative sign in the polynomial.</dd>
</dl>
<dl class="attribute">
<dt id="yaff.pes.vlist.Chebychev3.kind">
<tt class="descname">kind</tt><em class="property"> = 7</em><a class="headerlink" href="#yaff.pes.vlist.Chebychev3.kind" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="yaff.pes.vlist.Chebychev3.get_log">
<tt class="descname">get_log</tt><big>(</big><big>)</big><a class="headerlink" href="#yaff.pes.vlist.Chebychev3.get_log" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="yaff.pes.vlist.Chebychev4">
<em class="property">class </em><tt class="descclassname">yaff.pes.vlist.</tt><tt class="descname">Chebychev4</tt><big>(</big><em>A</em>, <em>ic</em>, <em>sign=-1</em><big>)</big><a class="headerlink" href="#yaff.pes.vlist.Chebychev4" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#yaff.pes.vlist.ValenceTerm" title="yaff.pes.vlist.ValenceTerm"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.vlist.ValenceTerm</span></tt></a></p>
<p>A fourth degree polynomial: 0.5*A*(1 -+ T4)
where T4=8*x**4-8*x**2+1 is the fourth Chebychev polynomial of the
first kind.</p>
<p>This is used for a computationally efficient implementation of torsional
energy terms, because the only computation of the cosine of the dihedral
angle is needed, not the angle itself.</p>
<p>This term corresponds to multiplicity 4. The minus sign corresponds to a
rest value of 0 degrees. With a the plus sign, the rest value becomes
45 degrees.</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>A</dt>
<dd>The energy scale of the function (in atomic units).</dd>
<dt>ic</dt>
<dd>An <tt class="docutils literal"><span class="pre">InternalCoordinate</span></tt> object.</dd>
<dt>sign</dt>
<dd>Choose positive or negative sign in the polynomial.</dd>
</dl>
<dl class="attribute">
<dt id="yaff.pes.vlist.Chebychev4.kind">
<tt class="descname">kind</tt><em class="property"> = 8</em><a class="headerlink" href="#yaff.pes.vlist.Chebychev4.kind" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="yaff.pes.vlist.Chebychev4.get_log">
<tt class="descname">get_log</tt><big>(</big><big>)</big><a class="headerlink" href="#yaff.pes.vlist.Chebychev4.get_log" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="yaff.pes.vlist.Chebychev6">
<em class="property">class </em><tt class="descclassname">yaff.pes.vlist.</tt><tt class="descname">Chebychev6</tt><big>(</big><em>A</em>, <em>ic</em>, <em>sign=-1</em><big>)</big><a class="headerlink" href="#yaff.pes.vlist.Chebychev6" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#yaff.pes.vlist.ValenceTerm" title="yaff.pes.vlist.ValenceTerm"><tt class="xref py py-class docutils literal"><span class="pre">yaff.pes.vlist.ValenceTerm</span></tt></a></p>
<p>A sixth degree polynomial: 0.5*A*(1 -+ T6)
where T6=32*x**6-48*x**4+18*x**2-1 is the sixth Chebychev polynomial of
the first kind.</p>
<p>This is used for a computationally efficient implementation of torsional
energy terms, because the only computation of the cosine of the dihedral
angle is needed, not the angle itself.</p>
<p>This term corresponds to multiplicity 6. The minus sign corresponds to a
rest value of 0 degrees. With a the plus sign, the rest value becomes
30 degrees.</p>
<p><strong>Arguments:</strong></p>
<dl class="docutils">
<dt>A</dt>
<dd>The energy scale of the function (in atomic units).</dd>
<dt>ic</dt>
<dd>An <tt class="docutils literal"><span class="pre">InternalCoordinate</span></tt> object.</dd>
<dt>sign</dt>
<dd>Choose positive or negative sign in the polynomial.</dd>
</dl>
<dl class="attribute">
<dt id="yaff.pes.vlist.Chebychev6.kind">
<tt class="descname">kind</tt><em class="property"> = 9</em><a class="headerlink" href="#yaff.pes.vlist.Chebychev6.kind" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="yaff.pes.vlist.Chebychev6.get_log">
<tt class="descname">get_log</tt><big>(</big><big>)</big><a class="headerlink" href="#yaff.pes.vlist.Chebychev6.get_log" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">2. <tt class="docutils literal"><span class="pre">yaff.pes</span></tt> &#8211; Force-field potential energy surfaces (PESs)</a><ul>
<li><a class="reference internal" href="#module-yaff.pes.dlist">2.1. <tt class="docutils literal"><span class="pre">yaff.pes.dlist</span></tt> &#8211; Short-range neighbor lists for covalent energy terms</a></li>
<li><a class="reference internal" href="#module-yaff.pes.ext">2.2. <tt class="docutils literal"><span class="pre">yaff.pes.ext</span></tt> &#8211; Low-level C routines</a></li>
<li><a class="reference internal" href="#module-yaff.pes.ff">2.3. <tt class="docutils literal"><span class="pre">yaff.pes.ff</span></tt> &#8211; Force field models</a></li>
<li><a class="reference internal" href="#module-yaff.pes.generator">2.4. <tt class="docutils literal"><span class="pre">yaff.pes.generator</span></tt> &#8211; Automatically generate force field models</a></li>
<li><a class="reference internal" href="#module-yaff.pes.iclist">2.5. <tt class="docutils literal"><span class="pre">yaff.pes.iclist</span></tt> &#8211; Internal-coordinate lists for covalent energy terms</a></li>
<li><a class="reference internal" href="#module-yaff.pes.nlist">2.6. <tt class="docutils literal"><span class="pre">yaff.pes.nlist</span></tt> &#8211; Neighbor lists for pairwise (non-bonding) interactions</a></li>
<li><a class="reference internal" href="#module-yaff.pes.parameters">2.7. <tt class="docutils literal"><span class="pre">yaff.pes.parameters</span></tt> &#8211; Object-oriented representation of parameter files</a></li>
<li><a class="reference internal" href="#module-yaff.pes.scaling">2.8. <tt class="docutils literal"><span class="pre">yaff.pes.scaling</span></tt> &#8211; Short-range scaling of pairwise interactions</a></li>
<li><a class="reference internal" href="#module-yaff.pes.vlist">2.9. <tt class="docutils literal"><span class="pre">yaff.pes.vlist</span></tt> &#8211; Module for the complete list of covalent energy terms.</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="rg_yaff.html"
                        title="previous chapter">1. <tt class="docutils literal"><span class="pre">yaff</span></tt> &#8211; YAFF - Yet another force field</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="rg_yaff_sampling.html"
                        title="next chapter">3. <tt class="docutils literal"><span class="pre">yaff.sampling</span></tt> &#8211; Phase-space sampling</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/rg_yaff_pes.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="rg_yaff_sampling.html" title="3. yaff.sampling – Phase-space sampling"
             >next</a> |</li>
        <li class="right" >
          <a href="rg_yaff.html" title="1. yaff – YAFF - Yet another force field"
             >previous</a> |</li>
        <li><a href="index.html">Yaff 1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2011, Toon Verstraelen, Louis Vanduyfhuys.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>